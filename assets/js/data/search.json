[ { "title": "Curta CTF ZSafe Write-up", "url": "/posts/curta-zsafe-writeup/", "categories": "ctf-writeups", "tags": "solidity, EVM, smart contracts, security", "date": "2024-01-18 10:07:00 +0100", "snippet": "This is a write-up for the Curta CTF ZSafe challenge. Iinitially didn’t submit a solution due to personal time constraints and issues with foundryscripts that made it impossible to submitdirectly using them. Instead I committed to the solve on Twitter.I did end up submitting landing me on 3rd,while I technically committed to the solution online before jinseo.eth came in 2nd I thinkit’s not fair to claim that I was “truly” 2nd as with CTFs actually submitting and debugging thefinal details of your solution is often half the battle.You can see my full solution in my repo here.IntroThe end goal is to have the SafeCurta puzzle contract’s verify function evaluate true for your seedwhich is determined by generate. To do so it checks that your associated SafeChallenge factorycontract returns isUnlocked.Our setup is: Deploy the SafeChallenge contract Find a way to pass the checks in its unlock function to achieved the isUnlocked: true state.To unlock the SafeChallenge contract (referred to as the lock from here on out) we must pass theunlock method 3 r values and 3 s values that when combined with the values of the proxycontract gives us 6 valid signatures for the set owner:function unlock(bytes32[3] calldata r, bytes32[3] calldata s) external { for (uint256 i = 0; i &lt; 2; ++i) { require(uint256(r[i]) &lt; uint256(r[i + 1])); } for (uint256 i = 0; i &lt; 3; ++i) { check(r[i], s[i]); } isUnlocked = true;}function check(bytes32 _r, bytes32 _s) internal { uint8 v = 27; address owner = proxy.owner(); bytes32 message1_hash = keccak256(abi.encodePacked(seed, address(0xdead))); bytes32 r1 = transform_r1(_r); bytes32 s1 = transform_s1(_s); address signer = ecrecover(message1_hash, v, r1, s1); require(signer != address(0), \"no sig match :&lt;\"); require(signer == owner, \"no owner match :&lt;\"); bytes32 message2_hash = keccak256(abi.encodePacked(seed, address(0xbeef))); bytes32 r2 = transform_r2(_r); bytes32 s2 = transform_s2(_s); address signer2 = ecrecover(message2_hash, v, r2, s2); require(signer2 != address(0), \"no sig match :&lt;\"); require(signer2 == owner, \"no owner match :&lt;\");}We quickly realize that this is impossible. As defined in the whitelisted SafeSecret and SafeSecretAdmincontracts, they do not give us enough freedom with the return values to be able to create validsignatures. This is mainly because of the lock’s transform_s2 method which derives the $s$ valuefor the second signature of every check:function transform_s2(bytes32 s) internal view returns (bytes32) { return keccak256(abi.encodePacked(uint256(s) ^ proxy.p2(), seed));}The fact that it derives the second $s$ value from a hash means that we cannot reverse some useful final$s$ value to see what p2() value SafeSecretAdmin would need to return. Our only path is tochoose some random p2() see what hash it results in and try to reverse the other values, but thisis mathematically impossible without breaking the keccak hash function or dlog (fundamentalcryptographic hardness assumption related to ECDSA).So our only path forward is to somehow manipulate the proxy with a custom implementation such thatp2() returns 2 separate values per check.Part 1: Bypassing the upgrade whitelist.To be able to manipulate how the proxy returns values for the check function you need to upgradethe proxy to code we control. However the whitelist only lets us change the implementation toa contract matching the code hash of the SafeSecret or SafeSecretAdmin contracts. However oncethe address is set the code is never revalidated, meaning if we are somehow able to change the codeof a deployed contract in-place we can just upgrade the proxy to some “valid” code, change it andvoila we have our malicious proxy implementation.This can be achieved with the metamorphic contract pattern. Summarized what it does is deploya contract using create2 such that the address of the contract is independent of its final runtimebytecode, instead it retrieves/builds its final bytecode in the constructor by using externalinformation. By combining this with SELFDESTRUCT we can wipe the code and then redeploy differentcode to the same address:contract ReinitFactory is IReinitFactory { bool private _copy; address private _target; function fakeDeploy(address target, address victim) external returns (address upgrade) { _copy = true; _target = target; upgrade = address(new FakeUpgrade{salt: bytes32(0)}()); } function deployActual(address real, address victim) external { _copy = false; _target = real; new FakeUpgrade{salt: bytes32(0)}(); } function mode() external view override returns (bool, address) { return (_copy, _target); }}contract FakeUpgrade { error SetFailed(); constructor() { (bool copy, address target) = IReinitFactory(msg.sender).mode(); if (copy) { assembly { let size := extcodesize(target) extcodecopy(target, 0, 0, size) return(0, size) } } else { // Create minimal proxy bytecode. bytes memory code = abi.encodePacked(hex\"3d3d3d3d363d3d37363d73\", address(target), hex\"5af43d3d93803e602a57fd5bf3\"); assembly { return(add(code, 0x20), mload(code)) } } }}So we can now use these contracts to deploy a contract that initially has a matching codehash to oneon the whitelist. Note that for the branch where we insert our actual bytecode I only deploya minimal proxy pointing to the actual code. While this adds some indirection it saves me a lot ofgas when deploying the solution as I only have to deploy my final solution bytecode once instead oftwice.Part 2: Self-destructing the ImpostorNow that we’ve deployed our own contract with the identical bytecode and upgraded to it we needto actually trigger a self-destruct, however, the code we’ve copied doesn’t have one. We can stillself-destruct, we’ll just need to do so in another context. Specifically within a DELEGATECALL.Notice that the upgradeToAndCall function in SafeUpgradeable allows us to not only set theimplementation but make an “initializing call” if: The new implementation is whitelisted You pass the onlyProxy check(code slightly simplified from actual CTF)function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy { _authorizeUpgrade(newImplementation); ERC1967Utils.upgradeToAndCall(newImplementation, data);}function _authorizeUpgrade(address newImplementation) internal { require(whitelist[newImplementation.codehash], \"wtf no whitelisted no hacc pls\");}The first is easy to do, to be allowed to DELEGATECALL into an arbitrary contract we can simplywhitelist it by calling the initialize method. For the second let’s look at the _checkProxymethod underlying the modifier:function _checkProxy() internal view virtual { if (address(this) == __self || ERC1967Utils.getImplementation() != __self) { revert(\"No hacc\"); }}We need to pass two checks:a) That the contract’s address is not __selfb) The set proxy implementation is __selfWell, what is __self?address private immutable __self = address(this);Well __self is an immutably stored variable containing address(this). Immutables are stored aspart of the bytecode and set at initialization meaning you can’t change them without affecting thecode hash. When we copy the code for our imposter upgrade we copy the original address, meaningwe implicitly pass the first check as our new contract’s address is by definition not the previousone.For the second check we can’t directly set the implementation without doing an upgrade, this is acircular dependency. As the code stands we can’t pass it. However notice that the code hash onlyencapsulates the runtime bytecode, not the deployment bytecode. Meaning that we just have to setthe implementation in the deploy code for our imposter contract.With all the hurdles passed we trigger an upgrade, DELEGATECALL-ing to a contract thatself-destructs on our behalf. Assuming we’ve set up the factory and create2 deployment correctlywe can then re-deploy any code we’d like to the address that’s now the implementation of theSafeChallenge.proxy contract:Part 3: Passing the check itselfNow that we’re able to actually fully control the target bytecode we need to actually createsignature values that’ll pass the 3 calls to check in the lock (SafeChallenge) contract.To reach the desired unlocked state we need to provide inputs into the unlock function such thatthe validation passes. The unlock function runs the check function 3 separate times on 3 pairsof inputs that we can provide. It also calls the proxy’s p1 and p2 methods for extra information,data that we can now control with our implanted implementation.We need all the inputs to result in 2 separate signatures $(v, r, s)$ for 2 distinct messages.Assuming keccak isn’t broken these are guaranteed to be different due to their differing salt(0xdead and 0xbeef respectively). Furthermore, the owner is only queried once and cannot change.The contract checks that both signatures were made by the same address and therefore the samekey.The neat thing about controlling the proxy however is that we can modify our owner(), p1() andp2() methods such that they return different values for every call of check despite being viewfunctions. The p2() method is also called two separate times to derive the s value for the firstand second signature meaning we can provide up to 6 different values via p2().As initially introduced, the second signature in check poses an issue, transform_s2 derivesthe $s$ value of the second signature via the keccak hash function. Cryptographic hash functionsare impossible to reverse (that we know of) so the second signature at least can’t be one thatwas generated from a private key. However, we don’t need it to be. Thanks to the mathunderyling ECDSA we can reverse the equation to compute the private key from a final signature,reversing the process.The ECDSA signature generation algorithm is defined as follows (minus some checks): Pick a random $k \\in [1, n-1]$. Compute the coordinates $(x, y)$ of the point $K = k\\cdot G$ Set the $r = x$ Compute $s = k^{-1} \\cdot (z - r \\cdot d_A)$ (where $z$ is our message hash and $d_A$ our private key)We can retrieve the private key to generate a valid signature for a given s by reversing the last equation:\\[s = k^{-1} \\cdot (z - r \\cdot d_A)\\]\\[d_A = (s \\cdot k - z) \\cdot r^{-1}\\] The reason you can’t normally reverse an ECDSA signature to retrieve the original private key is becausethe underlying $k$ parameter is not meant to be known. If you have a cryptographic library thatsomehow leaks or reuses $k$ it allows you to extract the private keys that created signaturesusing it. In our situation since we control the process, we can choose and therefore know $k$.For our second signature, we can simply pick a random $k$ and p2() (denoted as $p_{2,2}$), hash$p_{2,2}$ to get $s_2$, compute $r$ from $k$ and get the private key using the above derivation.Now we simply sign the first hash using the derived private key and voila we have two distinctsignatures $(v, r_1, s_1)$ and $(v, r_2, s_2)$ with $s_2$ being the result of a hash.We now just compute $p_1$ for each check such that $r_2 = r_1 + p_1$ ($p_1 = r_2 - r_1 \\mod 2^{256}$) andconfigure p2() to return $s_1$ then the original $p_{2,2}$ we used to compute $s_2$. We can set theexternally supplied s values to 0 so that it does not affect the output of p2() when XOR-ed intransform_s1 and transform_s2.One last final issue is that the lock contract sees the proxies p1(), p2() and owner() methodsas view-functions, meaning solc will compile the contract down to use STATICCALL to call themethods. This means we cannot modify in our methods. Without having access between the calls (whichwe do not), how do we make these functions stateful such that they “know” how often they were calledso that they can return different values each time?One way would be to set and check for a hardcoded gas remaining value, as gas will be usedthroughout the call and different amounts will be remaining. However trying to plan for and dealwith specific gas uses is very finicky and I would not recommend such an approach.Instead we can make these view methods stateful by taking advantage of the EVM’s storage cold/warm gasaccounting. When a storage value is first read as part of a transaction it incurs a larger “warming”cost of 2100 to account for the node’s cost of fetching the value from its DB on disk, everysubsequent time the value is SLOADed however, it only incurs a cost of 100 gas as it’s already“warm” and cached locally for the duration of the transaction. This means we can use the gas cost ofloading variables to determine whether they’ve been read already, giving us a stateful butSTATICCALL-compatible way to return different values:function p2() external view returns (uint256) { uint256 i = 0; unchecked { while (true) { uint256 preGas = gasleft(); uint256 p = p2s[i]; uint256 afterGas = gasleft(); if (preGas - afterGas &gt; 2100) return p; i++; } } revert();}Voila! Solved. We then simply stitch together the deployment and submission of our differenttransactions, test against a local fork before deploying on-chain. (Or in my case, accidentallydeploy directly to mainnet, test locally before finally redeploying the fixed solution to mainnet).ConclusionOverall this was a very interesting challenge by Zellic’s jazzy,taking advantage of some interesting math behind ECDSA and some false assumptions people commonlymake about the immutability of code. Highly recommend you try it out, feel free to check out thecode to my solution on github as well. Itcontains not only the challenge and solution contracts but the python script I used to actually runthe above math and generate the different values.Feel free provide feedback on this post on Twitter (X) orsimply follow for more smart contract development and CTF content in the future! 😁" }, { "title": "Quitting DeReg And What's Next", "url": "/posts/quitting-dereg/", "categories": "", "tags": "personal", "date": "2023-11-24 17:58:00 +0100", "snippet": "IntroductionFor just over a year now I’ve been working on a startup called “DeReg”, mostly full-time togetherwith my amazing brother &amp; co-founder Dimitri. Recently we havedecided to stop the project so that we can each work on other things and pursue things we’re moreinterested in.This post explains my personal motivation for initially starting the project and now quitting. Ina separate post (soon™️) I’ll lay out the original vision we had with the hope that someone elsewill be inspired and at least borrow a few ideas.Why I started DeRegOutside of believing that the core idea made sense from both a business and technical perspective,my primary goal with DeReg was to upskill as a person. While I believe being an engineer is greatI don’t think it’s enough. In my life I want to have a large positive impact, not only on the peopleclosest to me but on the world at large, I want to do big things.Long-term, to do that I believe I need to upskill to be a leader/founder who knows how tostructure capital, allocate resources and manage people. To do that I can’t be a 1-dimensionaldeveloper. The idea behind DeReg was to do a trial by fire, beginning to acquire these skills witha “learning by doing philosophy” and hopefully also build an amazing startup along the way, thatrevolutionized the DeFi security industry and maybe even made a ton of money to pour back into thenext thing.Why I’m QuittingMainly and most importantly the project wasn’t satisfying me. While I want more, at heart I’m anengineer and the technical challenges associated with DeReg weren’t fascinating to me. I wasprocrastinating a lot and getting nerd-sniped by other technical challenges that were almostalways outside of the scope of DeReg.Before deciding to quit I was contemplating this a lot, would I eventually get out of therut, discovering a new type of challenge that would suck me in? What if all I needed was tocomplete fundraising and the pressure of having all these new commitments would force me intobeing productive, out of sheer necessity?I’m so grateful to my brother for talking openly to me and helping me get the clarity I needed.I’m still very young, 21 in fact, I don’t need to be sure about what I want to do yet. It’s ok tostray and experiment and I definitely shouldn’t lock myself in with new responsibilities untilI’m sure about what I want to do. Overall I love my brother and am very happy our first lil’ venturetogether had such an amicable ending. ❤️I’m also forever grateful to libevm a dear friend and our onlyinvestor. Their investment has been returned in full in &lt;2 months with a 6% profit. Now I canproudly say that “my first venture ever resulted in a profit for all investors with an averageannualized return of over 50%”. 😂😏Jokes aside I thought I was sure about wanting to do a startup, I thought it was the best, logicalnext step. I still think I was right, but maybe not. Life is funny like that sometimes, no matterhow hard you try to self-impose some grander vision and strict timeline onto yourself, sometimes youjust have to go with the flow. As Bruce Lee famously said: “Be water, my friend”.So What’s Next? 🏔️In the short term, I’ll be working on passion projects / nerd-snipes and freelancing again.I’ll also be moving to Lisbon! 🇵🇹The main side project I’m going to be finishing first isMETH, my hyper-optimized Wrapped Ether implementation.After/next to that I have a few other projects planned: Repurposing METH to create an ERC20 factory for anybody to deploy their own hyper-optimized ERC20 token Contribute to Venom, Vyper’s new IR Optimize the Safe Multisig contract using sstore3 Contribute to foundry, improving traces (add the ability to have storage &amp; address cold/warm accesses be marked, displaying internal calls similar to what Tenderly provides) Continue helping with the circuit breaker ERC (ERC7265) Interactive disassemblerNot sure which of these I’ll do and in which order but they’re the ones on my mind. Needless to saythat while DeReg is over, for now, I still believe in Circuit Breakers and their potential and willcontinue working with my collaborators on a good circuit breaker standard and implementation.For the medium term, I’m looking at colleges again and seeing if I can go back to studying nextyear. I dropped out during Covid, before even finishing my 1. semester to work as a senior auditorat Quantstamp. Now that things have cleared out I’m getting some FOMO and curious what the studentexperience is like. Worst case I realize it’s not for me, “wasted” a little time and go back todoing just philogy things.Maybe Your Employee? 👉👈While I’m not actively looking I’m very open to employment opportunities. Specifically, if it matchesthe following criteria: research/engineering role hard and somewhat diverse technical challenges collaborative work environment cracked teammates I can look up to and learn from good pay (210k and up / yr)While my main expertise is in low-level smart contract development and EVM security I’m a fastlearner and very open to learning things I’m not already well-versed in such as: Rust (already know basics but far from good) ZK-Cryptography MEV CompilersLe EndThanks for reading and allowing me to share some of my personal story with you. Hopefully, you tookaway something from this article too. Looking forward to the future. Expect more technical contentsoon. 👀Follow me on Twitter ($X$). DM there for inquiries. 📩" }, { "title": "Beancount: DeFi Accounting For Noobs", "url": "/posts/defi-accounting-for-noobs/", "categories": "acounting, DeFi", "tags": "DeFi, accounting, beancount", "date": "2023-10-01 20:45:00 +0200", "snippet": " Disclaimer While it should be common sense, just in case someone doesn’t understand this: you should not blindly listen to a post onthe internet on how to pay your taxes, do accounting, or even trade for that matter. Doing any ofthose actions wrong may result in you harming your finances and/or becoming legally liable if youe.g. misstate your income on tax forms. I’m neither a professional accountant, tax advisor norlawyer. The content of this post is meant to be educational and should not be consideredprofessional advice of any kind. If you intend to apply anything from this post do so at your ownrisk and consult a professional as this post almost definitely contains errors and oversimplifications.IntroThis blog post will give you a practical introduction to accounting in the context of DeFi.I’ve created this post to share some of my learnings as an amateur, self-taught bookkeeper andexpand the community of accounting-interested DeFi users. Hopefully, I can help some of you with yourdaily crypto / DeFi trading activities. 😄Reasons To Learn Basic AccountingBefore diving into the actual content I wanted to lay out some reasons why you might want to learnthe basics of accounting if you’re not already motivated / interested. If you already know why youwant to learn feel free to skip to the next section. Tax Compliance 🥸: If you want to easily and accurately determine your income you needa consistent system Tax Avoidance 😎: If you want to save on taxes you need to understand your tax laws and how youcan legally leverage them to your benefit Insight &amp; Understanding 📊: Accounting allows you to notice and quantify trends in your financesas well as understand how you’re spending and earning it if you want to be able to optimizesomething you have to be able to measure it first Unique mental model 🧠: If you’re a DeFi smart contract developer or auditor understanding the basics offinancial accounting can give you a unique way of modeling value changes and transactions inprotocols, adding another useful mental model to apply to protocols.The Downsides Of An External AccountantWhile you could hire an accountant to do everything for you, unless you have a pretty sizablenet worth it will hardly be worth the cost. Most accountants are not familiar with crypto let aloneobscure DeFi protocols. If your activity consists of more than just basic spot trades you’ll likelyhave to spend time, money, and effort explaining to a normal accountant how the different DeFiprotocols, farms, NFTs, and airdrops work.Furthermore not having direct control of your “books” (accounting lingo for where all yourtransactions, inventory, etc. are kept track of) limits your ability to optimize your taxes, makingyou completely reliant on advice from your accountant or other advisors.💼 Crypto Tax Software &amp; When To Get Help From ExpertsWhile this whole post is about accounting basics and how to easily keep track of one’s books thereare situations where you can and probably should consult with an expert. When it comes to filingtax statements for your yearly/quarterly reporting or better understanding the tax laws and howthey apply to your specific situation you should definitely consult professionals.In fact, if you’re just doing basic trades on exchanges and the popular DeFi protocols you shouldprobably just use one of the many existing crypto tax software. They’ll save you a lot of effortby automating the importing and classification of transactions.My approach is to do the accounting myself while consulting a tax advisor on the generallaws and how they might apply to my situation. When it comes time to report my taxes I also compilea bunch of summaries from my accounting and hand it over to the tax advisor for them to double-checkand submit the necessary tax statements in a proper manner.🫘 BeancountBeancount is an open-source, easy-to-use text-based accounting tool. Unlike commercialaccounting programs, its base feature set is relatively limited. While this may sound likea downside I think this is actually very useful as it makes it easy to use without getting distractedby overviews, charts, and features I don’t need.While Beancount is simple at its core you can choose to make it as sophisticated as you want byinstalling and/or writing your own plugins or by simply leveraging the command-line tools that comealong with beancount. Beancount has a very nice API making it easy to extend with Python.Furthermore, as part of its core feature set, it has some very nice handling of inventory or as itprefers to call it in its documentation “commodities”. Whilenot specifically made for crypto it’s very well suited for accounting crypto transactions.InstallationInstalling beancount is very simple, but it requires you to have Python and its package managerpip already installed. If you don’t have those already I’d recommend just doing a quick search“how to install python and pip on (windows / mac / linux)”. If you’re on a Linux distro, Python andpip may already be installed so just check. Once pip is installed you can install beancount byrunning the following in a command line:pip install beancount # or pip3 install beancountNext to beancount I’d highly recommend also installing the fava web interface for beancount.It allows you to have a visual interface in your browser to see your finances and even allows you tomake basic entries. To install fava run pip install fava.✏️ Editing FilesBeancount and the CLI (command line) tools that come installed with it are mainly there to help yougain insight and create summaries based on your entries. Beancount entries are tracked in.beancount files which are created and edited manually, the .beancount format is a simple,human-readable text format for accounting financial data. For editing such files I’d highlyrecommend using an editor like VS Code, while it’s typically usedby programmers note you don’t need to know how to code to be able to use beancount.If you choose to go with VS Code you should install the Beancount plugin, it’ll give you syntaxhighlighting, auto alignment, auto-completion, and more to make it even easier to manage yourentries.📚 Accounting Basics: Double-Entry BookkeepingNow that we’ve installed the tool I’ll be demonstrating the accounting concepts, how they relate tocrypto / DeFi accounting and how to apply them using beancount.🗒️Your First LedgerYour “ledger” or “books” is the central store of all your transactions. In beancount it’s a set offiles with the .beancount extension. Let’s go ahead and create our first ledger, I’ll call itMain.beancount but the name doesn’t really matter:If you just want to make a small note or remark for yourself you can add a so-called comment byprepending the line with a semi-colon ;:; This is a comment; Doesn't matter what I say here beancount won't recognize it and it won't break my file!Next you’ll want to specify your base currency, unless you’re a DAO that wants to do its accountingin a stablecoin or crypto coin like ETH or BTC you should pick your the fiat currency you useday-to-day and report your taxes in. While I don’t live in the US for the sake of this post I’ll gowith US-Dollars:; Defines the base currency (remember this is a comment):option \"operating_currency\" \"USD\"Now that the bare basics are set up you can start fava by opening a terminal and runningfava Main.beancount in the folder your ledger is in:You can then go to the shown address (likely https://localhost:5000) in your browser to get avisual overview of what you’re changing, but ignore it for now because your ledger is empty.Transactions &amp; AccountsIn double entry accounting, a transaction is recorded anytime an event persistently changes yourfinances e.g.: A cash transfer from one bank account to another Purchase of an item with a credit card Receiving a bill Buying 100$ worth of ETH Receiving interest Paying a bill you received 2 months agoThe “receiving bill” example may be an unintuitive one, how does “receiving a bill” affect my finances? Wellwhen you receive a bill you’re being made aware of money you now owe someone. While this post isaimed at DeFi accounting these examples are meant to demonstrate what transactions roughlyrepresent in the double-entry accounting framework.Let’s add a simple transaction to our ledger denoting a $500 transfer from a “Bank A” to “Bank B”:2022-12-18 * Assets:Bank-A -500.00 USD Assets:Bank-B 500.00 USDA transaction in beancount starts with a date in iso format &lt;year&gt;-&lt;month&gt;-&lt;day&gt; and a *. It’s thenfollowed by rows of postings, which each posting affecting a specific account. You can also add anoptional “payee” and “narration” explaining where and what you’re doing, they must be in quotes. For example:2022-12-18 * \"JP Morgan\" \"Rebalancing to my Chase account\" Assets:Bank-A -500.00 USD Assets:Bank-B 500.00 USDThis will help you later understand what a transaction is and why it was done so it’s highlyrecommended you add at least narration to your transactions. The payee and narration must always bein quotes \".If you’ve saved your file and have the VS Code plugin or fava running you’ll notice they’recomplaining about errors in your ledger file (note I have relative line numbers on which is why theylook weird on my end):This happens because beancount needs you to define the accounts you’re going to use, thisrequirement helps you easily catch typos later. To define an account use the “open” directive, theerrors should disappear:2022-12-18 open Assets:Bank-A2022-12-18 open Assets:Bank-B2022-12-18 * \"JP Morgan\" \"Rebalancing to my Chase account\" Assets:Bank-A -500.00 USD Assets:Bank-B 500.00 USDYou can call accounts whatever you’d like, colons : in the name are similar to the slashes / infile paths, they denote “parent” accounts, like folders allowing you to group together relatedaccounts:2020-12-18 open Assets:Cash:JPM:Savings2020-12-18 open Assets:Cash:JPM:Checking2020-12-18 open Assets:Cash:BofA2021-03-11 open Assets:Crypto:Tokens2021-03-11 open Assets:Crypto:Stables// running `bean-report Main.beancount accounts | treeify`-- Assets |-- Cash | |-- BofA | |-- JPM | |-- Checking | |-- Savings |-- Crypto |-- Stables |-- TokensTransactions can have more than two postings however, meaning you can express transactions thatchange more than 1 account:; Opening (doesn't have to on the same day)2022-12-18 open Assets:Cash:Bank-A2022-12-18 open Assets:Cash:Physical2022-12-18 open Expenses:Fees:Bank-A:ATM; Transaction2022-12-18 * \"Bank A\" \"ATM Withdrawal\" Assets:Cash:Bank-A -502.20 USD Assets:Cash:Physical 500.00 USD Expenses:Fees:Bank-A:ATM 2.20 USD🪨 BalanceA core rule of double-entry accounting which is also strictly enforced in beancount is that alltransactions must balance. Specifically they must balance to zero. It’s this rule combined withthe use of different account types that makes double-entry accounting so powerful. It ensures thateverything is kept track of in some way or another, if you create a transaction that doesn’t balancebeancount will give you an error.However to make your life easier beancount allows you to omit the value of one posting and willbalance the transaction for you automatically:; Opening (doesn't have to on the same day)2022-12-18 open Assets:Cash:Bank-A2022-12-18 open Assets:Cash:Physical2022-12-18 open Expenses:Fees:Bank-A:ATM; Transaction2022-12-18 * \"Bank A\" \"ATM Withdrawal\" Assets:Cash:Bank-A -502.20 USD Assets:Cash:Physical 500.00 USD Expenses:Fees:Bank-A:ATMYou can check the filled in values in fava under “Journal” or by runningbean-report Main.beancount print in your command line (bean-report is one of the CLI toolsautomatically installed alongside beancount).Account TypesIf all transactions must balance then “how do I account for income, expenses, purchases from debtor even assets I already had when I started?” you may ask. That’s where the different account typescome in.In double-entry accounting, accounts are not only where money is (asset accounts) but also where itcomes from (income accounts), where it went (expense accounts), where it’s going to go (liabilityaccounts) and where it has come from in the past (equity accounts).These 5 base types: Assets, Income, Expenses, Liabilities and Equity are also enforced bybeancount. Any valid account name must start with one of these as its root.Assets &amp; LiabilitiesAssets and liabilities are opposites and the simplest account types. Asset are everything you havein your posession, even if you owe it to someone and liabilities are everything you owe someone. Forexample when you borrow $10,000.00 worth of coins on a lending protocol you’d book both assets andliabilities, because you’re both getting the tokens you’re borrowing but you’re creating debt:; Opening2022-01-01 open Assets:Crypto:Tokens2022-01-01 open Liabilities:Crypto; Transaction2022-03-01 * \"Aave\" \"Borrow Tokens\" Assets:Crypto:Tokens 10,000.00 USD Income:Crypto:Interest -10,000.00 USDSimilarly if you make a purchase from a credit card:; Opening2022-01-01 open Liabilities:Credit-Cards:Mastercard-69692022-01-01 open Expenses:Living:Groceries; Transaction2022-06-01 * \"Walmart\" \"Weekly food shopping\" Liabilities:Credit-Cards:Mastercard-6969 -79.20 USD Expenses:Living:Groceries 79.20 USDExpenses &amp; IncomeCounterintuitively income accounts have a negative balance, this is because they’re a source offunds, meaning they’re deducted when used. If you do a lot of transactions with different DeFiprotocols, maybe even some freelance work and/or have a fixed job, having a good breakdown of incometypes by keeping track of corresponding income accounts can give you a good overview of how you madeyour money. Similarly expense accounts give you insight into how your money is spent.Here are two examples:; Opening2022-01-01 open Assets:Crypto:Tokens2022-01-01 open Assets:Cash:Bank-A2022-01-01 open Income:Crypto:Interest2022-01-01 open Income:Freelance:Consulting2022-01-01 open Expenses:Fees:Stripe; Transactions2022-03-01 * \"Aave\" \"Withdraw Interst\" Assets:Crypto:Tokens 30.00 USD Income:Crypto:Interest -30.00 USD2022-03-01 * \"Bob\" \"Payment for February\" Income:Freelance:Consulting -3,000.00 USD Assets:Cash:Bank-A 2,972.23 USD Expenses:Fees:StripeEquityEquity accounts are the weirdest account type, they basically represent what you’d have left over ifyou took all your assets and paid off your debts. They’re mainly used when you start a new ledger or“close a time period”. In accounting “closing” a time period basically means reseting the income&amp; expense accounts and moving any net profit / loss into equity:; Opening2022-01-01 open Equity:Opening-Balances2022-01-01 open Assets:Cash:Bank-A2022-01-01 open Income:Crypto:Interest2022-01-01 open Income:Freelance:Consulting2022-01-01 open Expenses:Fees:Stripe; Transactions2022-01-01 * \"Opening balances\"; inbetween transactions2022-03-01 * \"Bob\" \"Payment for February\" Income:Freelance:Consulting -3,000.00 USD Assets:Cash:Bank-A 2,972.23 USD Expenses:Fees:StripeI’ll go into closing a bit later.Equity in total should be negative, if it’s positive it means you owe more than you have(Liabilities &gt; Assets) and are theoretically insolvent.🪙 Inventory, Lots and Booking MethodsInventory &amp; LotsNow that we’ve covered the basics we can get into how to account crypto assets. You see theintuitive approach doesn’t work, while beancount accepts any type of currency for postings, not onlythe base currency we’ve defined if we try to book a simple trade it’ll give us an error:option \"operating_currency\" \"USD\"2022-01-01 open Assets:Cash:Exchange-A2022-01-01 open Assets:Crypto:Tokens2022-01-02 * \"Simple Trade\" Assets:Cash:Exchange-A -2,200.00 USD Assets:Crypto:Tokens 2.00 ETHSpecifically beancount is telling us that Transaction does not balance: (-2200.00 USD, 2.00 ETH).You see when you book assets in double-entry bookkeeping you book them at cost, like this thetransaction balances in USD:2022-01-02 * \"Simple Trade\" Assets:Cash:Exchange-A -2,200.00 USD Assets:Crypto:Tokens 2.00 ETH {1,100.00 USD, 2022-01-02}The price and date are denoted in the curly braces after the asset. This tells beancount that whilewe’re getting ETH we’re just converting $2,200.00 into $2,200.00 worth of ETH so that thetransaction balances. Similar to the postings auto-balance you can leave out the date and/or theprice and beancount will automatically fill it in for you (if you’re only buying one asset):2022-01-02 * \"Simple Trade\" Assets:Cash:Exchange-A -2,200.00 USD Assets:Crypto:Tokens 2.00 ETH {}Booking an asset or “commodity” as beancount likes to call it, like this creates a “lot”. A lot isa single acquisition / coin in your inventory. As you do multiple purchases and sales you willaccumulate different lots each with their own cost and date.In beancount lots also have an optional label which I use for NFTs:2022-01-01 open Assets:Cash:Exchange-A2022-01-01 open Assets:Crypto:NFTs2022-03-02 * \"NFT Purchase\" Assets:Cash:Exchange-A -10,000.00 USD Assets:Crypto:NFTs 1 GOBBLER {2,000.00 USD, \"id:401\"} Assets:Crypto:NFTs 1 GOBBLER {2,000.00 USD, \"id:402\"} Assets:Crypto:NFTs 1 GOBBLER {2,000.00 USD, \"id:403\"} Assets:Crypto:NFTs 1 GOBBLER {2,000.00 USD, \"id:404\"} Assets:Crypto:NFTs 1 GOBBLER {2,000.00 USD, \"id:405\"}The label has to be part of lot data in the curly braces, separated by a comma and in quotes. What’sin quotes is entirely up to you, I just like to use the id:&lt;token ID&gt; convention. While it’s verywell suited for crypto you can also use beancount’s lot system for other assets:2022-01-01 open Assets:Cash:Bank-A2022-04-20 open Assets:Real-Estate2022-04-20 open Liabilities:Mortgages:Home2022-04-20 * \"Closing the purchase of new home\" Assets:Cash:Bank-A -50,000.00 USD Liabilities:Mortgages:Home -450,000.00 USD Assets:Real-Estate 1 PROPERTY {500,000.00 USD, \"42th Avenue 69th Street, 10019 NY\"}If you want to see your full inventory you can go to fava under the Holdings tab. I don’t likethat overview too much however so I made this custom query you can run under fava’s Query tab orusing beancount’s bean-query tool:SELECT account, cost_date, sum(units(position)) as units, sum(cost(position)) as cost_total, cost_label as labelWHERE currency != 'USD'GROUP BY currency, account, cost_date, cost_labelORDER BY account, currency, cost_dateBooking Methods(source)1Now that we know how to book cryptocurrencies when we acquire we have to know how to dispose ofthem. The main problem or rather question here is in what order to you use your lots?Consider the inventory resulting from the following purchases:2022-01-01 open Assets:Cash:Exchange-A2022-01-01 open Assets:Crypto:Tokens2022-01-01 open Assets:Crypto:NFTs2022-01-02 * \"Simple Trade\" Assets:Cash:Exchange-A -2200.00 USD Assets:Crypto:Tokens 2.00 ETH {1100 USD, 2022-01-02}2022-03-02 * \"Simple Trade\" Assets:Cash:Exchange-A -3300.00 USD Assets:Crypto:Tokens 1.50 ETH {2200 USD, 2022-03-02}2022-06-02 * \"Simple Trade\" Assets:Cash:Exchange-A -1200.00 USD Assets:Crypto:Tokens 0.8 ETH {1500.0 USD, 2022-06-02} Account Date Units Cost Total Label Assets:Crypto:Tokens 2022-01-02 2.00 ETH 2200.00 USD None Assets:Crypto:Tokens 2022-03-02 1.50 ETH 3200.00 USD None Assets:Crypto:Tokens 2022-06-02 0.80 ETH 1200.00 USD None If you were to sell 1 ETH at the current price which “coin(s)” would you sell? The method by whichyou choose lots to be used is called the “booking method” and depends on your taxs laws. Somecountries give you more freedom to choose and some less. There can also be differences between whatbooking rules private individuals vs. corporations can use.FIFO (First In First Out)The “First In First Out” booking method, dictates that the oldest lots are to be used first and isone of the most common booking methods. This method is applicable in both the US and Germany and issupported by beancount of the box:2022-01-01 open Assets:Cash:Exchange-A2022-01-01 open Assets:Crypto:Tokens \"FIFO\"2022-01-01 open Assets:Crypto:NFTs2022-01-02 * \"Simple Trade\" Assets:Cash:Exchange-A -2,200.00 USD Assets:Crypto:Tokens 2.00 ETH {}2022-03-02 * \"Simple Trade\" Assets:Cash:Exchange-A -3,300.00 USD Assets:Crypto:Tokens 1.50 ETH {}2022-06-02 * \"Simple Trade\" Assets:Cash:Exchange-A -1,200.00 USD Assets:Crypto:Tokens 0.8 ETH {}2022-09-13 open Income:Crypto:Gains-PnL2022-09-13 * \"not-FTX\" \"Sell some ETH\" Assets:Crypto:Tokens -1.00 ETH {} Assets:Cash:Exchange-A 1,717.80 USD Income:Crypto:Gains-PnLThe booking method is defined next to the account when it’s created. When you dispose of some assetsthe curly braces select which lot you’re selling. This allows you to pick specific lots / coinsbased on the date, cost or label. If you have a booking method configured you can leave the lotselector empty and beancount will automatically pick the right one for you and fill out the details:&gt; bean-report Main.beancount print2022-01-01 open Assets:Cash:Exchange-A2022-01-01 open Assets:Crypto:Tokens \"FIFO\"2022-01-01 open Assets:Crypto:NFTs2022-01-02 * \"Simple Trade\" Assets:Cash:Exchange-A -2200.00 USD Assets:Crypto:Tokens 2.00 ETH {1100 USD, 2022-01-02}2022-03-02 * \"Simple Trade\" Assets:Cash:Exchange-A -3300.00 USD Assets:Crypto:Tokens 1.50 ETH {2200 USD, 2022-03-02}2022-06-02 * \"Simple Trade\" Assets:Cash:Exchange-A -1200.00 USD Assets:Crypto:Tokens 0.8 ETH {1500.0 USD, 2022-06-02}2022-09-13 open Income:Crypto:Gains-PnL2022-09-13 * \"not-FTX\" \"Sell some ETH\" Assets:Crypto:Tokens -1.00 ETH {1100 USD, 2022-01-02} Assets:Cash:Exchange-A 1717.80 USD Income:Crypto:Gains-PnL -617.80 USDYour inventory is then also adjusted automatically: Account Date Units Cost Total Label Assets:Crypto:Tokens 2022-01-02 1.00 ETH 2200.00 USD None Assets:Crypto:Tokens 2022-03-02 1.50 ETH 3200.00 USD None Assets:Crypto:Tokens 2022-06-02 0.80 ETH 1200.00 USD None LIFO (Last In First Out)Similar to FIFO the LIFO rule dictates that the last lot i.e. the newest must be used first. Thisrule is also available in beancount and can be specified just like the FIFO rule:2022-01-01 open Assets:Crypto:Tokens \"LIFO\"Average Cost BookingUnlike FIFO and LIFO, average cost booking requires you to essentially merge all lots into one attheir average price. This method is used in the UK and Canada. This method is not yet supportedby beancount out-of-the-box and requires manual lot recreation or writing a custom plugin:2022-01-01 open Assets:Cash:Exchange-A2022-01-01 open Assets:Crypto:Tokens2022-01-01 open Assets:Crypto:NFTs2022-01-02 * \"Simple Trade\" Assets:Cash:Exchange-A -2,200.00 USD Assets:Crypto:Tokens 2.00 ETH {}2022-03-02 * \"Simple Trade\" Assets:Cash:Exchange-A -3,300.00 USD Assets:Crypto:Tokens -2.00 ETH {} Assets:Crypto:Tokens 3.50 ETH {}2022-06-02 * \"Simple Trade\" Assets:Cash:Exchange-A -1,200.00 USD Assets:Crypto:Tokens -3.50 ETH {} Assets:Crypto:Tokens 4.30 ETH {}2022-09-13 open Income:Crypto:Gains-PnL2022-09-13 * \"not-FTX\" \"Sell some ETH\" Assets:Crypto:Tokens -1.00 ETH {} Assets:Cash:Exchange-A 1,717.80 USD Income:Crypto:Gains-PnLSpecific ID &amp; HIFO (Highest In First Out)If you’re in the US and you document your purchases very well (which is something that beancount willenable you to do), then you can apply the “Specific ID” method2. This method allows you to chooseany lot from your inventory when you sell. This allows you to come up with and use essentially anybooking method you want, including the HIFO “highest in first out” method. The HIFO method dictatesthat you sell your most expensive lots first, this minimizes your realized gains or maximizes yourrealized losses, allowing you to minimize your tax burden when you sell.Selecting custom lots is supported by beancount but methods like HIFO are not supportedout-of-the-box and would either have to be done manually or via a custom plugin:2022-01-01 open Assets:Cash:Exchange-A2022-01-01 open Assets:Crypto:Tokens2022-01-01 open Assets:Crypto:NFTs2022-01-02 * \"Simple Trade\" Assets:Cash:Exchange-A -2,200.00 USD Assets:Crypto:Tokens 2.00 ETH {}2022-03-02 * \"Simple Trade\" Assets:Cash:Exchange-A -3,300.00 USD Assets:Crypto:Tokens 1.50 ETH {}2022-06-02 * \"Simple Trade\" Assets:Cash:Exchange-A -1,200.00 USD Assets:Crypto:Tokens 0.8 ETH {}2022-09-13 open Income:Crypto:Gains-PnL2022-09-13 * \"not-FTX\" \"Sell some ETH\" Assets:Crypto:Tokens -1.00 ETH {2022-03-02} Assets:Cash:Exchange-A 1,717.80 USD Income:Crypto:Gains-PnLIf you’re manually selecting lots you have to make sure that your selection in the curly brackets{ } is not ambiguousUniversal vs. Per Account BookingFIFO, LIFO and HIFO all require you to keep track of inventory you can book from. While you couldkeep track of one inventory for every account (Exchange A, Exchange B, Wallet 1, Wallet 2, etc.)this separation starts to break down when you transfer assets between locations. That’s why for cryptoit’s usually more practical to keep track of a single inventory and do “universal booking” meaningregardless where you buy / sell your assets you’re always booking from theDeFi AccountingNow that we’ve covered the basics, understand booking methods and how to account for basic tradesI wanted to go through some more examples related to DeFi and some other smaller nuances.Profit &amp; Loss Accounts (PnL Accounts)For gains related to crypto or other trading activity I create what I like to call “PnL accounts”they’re accounts where book all gains and losses of a certain type so that I can immediately see mynet gain and don’t have to check whether or not a given trade realized a loss or gain:2022-01-01 open Assets:Cash:Exchange-A2022-01-01 open Assets:Crypto:Tokens \"FIFO\"2022-01-01 open Assets:Crypto:NFTs2022-01-01 open Income:Crypto:Gains-PnL2022-01-01 * \"NFT Purchase\" Assets:Cash:Exchange-A Assets:Crypto:NFTs 1 GOBBLER {4,000.00 USD, \"id:400\"} Assets:Crypto:NFTs 1 GOBBLER {3,900.00 USD, \"id:401\"}2022-03-01 * \"ArtGobblers\" \"Sale\" Assets:Crypto:NFTs -1 GOBBLER {\"id:401\"} Assets:Cash:Exchange-A 2,000.00 USD Income:Crypto:Gains-PnL2022-08-01 * \"DCA into ETH\" Assets:Cash:Exchange-A -500.00 USD Assets:Crypto:Tokens 0.482 ETH {}; Includes Fee2022-11-13 * \"Uniswap\" \"Get some DAI\" Assets:Crypto:Tokens -0.202838 ETH {} Assets:Crypto:Tokens 322.113821 DAI {1.00 USD} Income:Crypto:Gains-PnLThis allows me to easily isolate and track my profit (or losses):2022-01-01 open Income:Crypto:Gains-PnL2022-03-01 * ArtGobblers | Sale 1900.00 USD 1900.00 USD2022-11-13 * Uniswap | Get some DAI -111.70 USD 1788.30 USDThe above overview can also be seen in fava by clicking on “Go to account” and selecting your PnLaccount.However if you want to breakdown your losses and gains into separate accounts you can do so. Youcould even automate the process with a plugin. Making a plugin is actually relatively easy, checkout the beancount docs on how to script plugins.Spread, Slippage &amp; FeesWhen you perform trades on exchanges, centralized or decentralized there are different factors thatreduce the value you’re able to get out of a trade. By “fees” I’m referring to explicit networkand/or exchange fees that are deducted from your account in exchange for facilitating the trade.Spreads and slippage on the other hand, while not the same thing, for the sake of accounting theymay as well be as they both represent deviations from your practical price and the actual marketprice.There are two approaches to account for these trade impacts: Direct accounting: calculate fees and slippage / spread and put them into respective lossaccounts Cost basis inclusion: add any cost associated with a trade to the cost basis of the output assetNot only is the second option simpler, the first may be incorrect depending on your tax laws. Yousee trading fees and price difference costs (slippage, spreads) are usually tax deductible howeverif you account them directly by puting them to an expense account, you’re moving forward the time ofthat deduction. To make it simpler let’s just look at a simple example with an exchange that chargesan unrealistic 25% fee:2021-01-01 open Assets:Cash:Exchange-A2021-01-01 open Expenses:Fees:Exchange-A2021-01-01 open Assets:Crypto:Tokens \"FIFO\"2021-01-01 open Assets:Crypto:NFTs2021-01-01 open Income:Crypto:Gains-PnL2021-06-13 * \"ETH DCA\" Assets:Cash:Exchange-A -2500.00 USD Expenses:Fees:Exchange-A 500.00 USD Assets:Crypto:Tokens 2.00 ETH {1000 USD, 2021-06-13}2022-07-14 * \"ETH Sale\" Assets:Crypto:Tokens -0.5 ETH {1000 USD, 2021-06-13} Assets:Cash:Exchange-A 450.00 USD Income:Crypto:Gains-PnL 50.00 USDVersus Cost inclusion:2021-06-13 * \"ETH DCA\" Assets:Cash:Exchange-A -2500.00 USD Assets:Crypto:Tokens 2.00 ETH {1250 USD, 2021-06-13}2022-07-14 * \"ETH Sale\" Assets:Crypto:Tokens -0.5 ETH {1250 USD, 2021-06-13} Assets:Cash:Exchange-A 450.00 USD Income:Crypto:Gains-PnL 175.00 USDYou see in the direct inclusion scenario the full expenses is booked in the first year (2021)although that loss hasn’t necessarily had a material impact yet. In the second scenario 1/4 of thefee is included as part of the loss because 1/4 of the original ETH amount is sold, the fee isimplicitly accounted for when a gain / loss from the affected amount is actually realized.Which method you can and should use really depends on your tax laws. Accounting the expenseimmediately can help reduce your tax bill but may also have you understate your net profit oroverstate your net loss. For these kinds of details it’s usually best to consult a professional asthey should be able to answer such questions quite easily and quickly if they have accounting / taxexpertise.Crypto IncomeWhether it’s freelance work or interest, income denominated in crypto is relatively easy to account,similar to a trade book the crypto to your assets at the current market price and the relevantincome account as source of the funds:2021-01-01 open Assets:Crypto:Tokens \"FIFO\"2021-01-01 open Income:Crypto:Gains-PnL2021-01-01 open Income:Crypto:Interest2021-01-01 open Income:Freelance:Consulting2022-03-03 * \"Bob\" \"Payment of invoice #1001\" Income:Freelance:Consulting Assets:Crypto:Tokens 1.7623 ETH {2,966.84 USD}; Withdrawal of original collateral not booked because you owned it before and still own it after the withdrawal; Only the change, the interest is accounted2022-07-31 * \"Aave\" \"Withdrawal of collateral + interest\" Income:Crypto:Interest Assets:Crypto:Tokens 34.110 DAI {0.996 USD} Be Aware Of Income Separation Depending on your tax laws you may not be able to deduct losses from crypto against incomeearned from your fixed job or freelance work because they’re classed as different types of income. This means that if you get paid in crypto and the price drops by 50% you may have to pay taxes onthe full value of the originially received amount as it was personal income while only being ableto deduct the 50% price fall from other crypto gains. If you get paid in crypto it’s vital you inform yourself to what extent there’s a separation sothat you can sell and set aside received crypto if necessary.Liquidity TokensLP Tokens are the fungible or non-fungible (NFT) tokens you get when providing liquidity to DEXslike Uniswap, Sushiswap or Pancakeswap. The tax implications of providing liquidity is hard todetermine in most of the world as there doesn’t really exist an equivalent instrument in the TradFiworld that tax authorities or advisors could really compare to.But looking at how they work we can at least try to account the intuitively: You give up 1 or 2 assets You receive another asset in return (the LP token/s) While you hold the LP asset it’s price can develop independently of the assets, accruing fees andgoing up or down in value based on the underlying When you get rid of the LP asset you receive 1 or 2 assets in different proprtionsBased on these circumstances I think it’s fair to say that when you provide liquidity you’redisposing i.e. practically selling your tokens for the LP asset:2021-01-01 open Assets:Crypto:Tokens \"FIFO\"2021-01-01 open Income:Crypto:Gains-PnL2021-01-01 open Income:Crypto:Interest2021-01-01 open Income:Freelance:Consulting2021-01-01 open Equity:Opening-Balances2022-09-03 * \"Opening Transaction\" Assets:Crypto:Tokens 6,000.00 DAI {1.0001 USD} Assets:Crypto:Tokens 4.23 ETH {1,720.00 USD} Equity:Opening-Balances2022-11-01 open Assets:Crypto:LP \"FIFO\"; price directive tells beancount about prices2022-11-01 price ETH 1,565.00 USD; Fee cost included2022-11-01 * \"Sushiswap\" \"Provide ETH / DAI liquidity\" Assets:Crypto:Tokens -3,000.00 DAI {} Assets:Crypto:Tokens -1.90384929272910 ETH {} Assets:Crypto:LP 629.37 SUSHI-LP {{5979.52 USD, \"DAI-ETH\"}} Income:Crypto:Gains-PnL You can indicate the total cost of the lot rather than the cost / unit by using double curlybraces: 2.0 ETH {1,200.00 USD}: Book 2 ETH at a cost of 1,200.00 USD each 3.0 ETH {{3,300.00 USD}}: Book 3 ETH at a total cost of 3,300.00 USD or1,100.00 USD each When you withdraw your underlying from your LP position you can then book the disposal of the LPasset although I’d put that into a separate LP account. Accounting this can be a bit tricky if youconsider that to withdraw from your LP you’re also spending gas and therefore desposing of ETH,booking a potentially separate loss / gain:2022-12-04 price ETH 1,242.161 USD2022-12-04 open Assets:Temp ; holds fee value2022-12-04 * \"Sushiswap\" \"Withdraw liquidity (network fee)\" Assets:Crypto:Tokens -0.003481 ETH {} Assets:Temp 4.324 USD ; Fee value Income:Crypto:Gains-PnL ; Profit / Loss from disposing ETH for fee2022-12-04 open Income:Crypto:LP2022-12-04 * \"Sushiswap\" \"Withdraw liquidity withdrawal\" Assets:Crypto:LP -629.3700 SUSHI-LP {\"DAI-ETH\"} Assets:Temp -4.3240 USD Assets:Crypto:Tokens 3,400.0000 DAI {1.00 USD} Assets:Crypto:Tokens 2.7375 ETH {1,242.161 USD} Income:Crypto:LPNote that I split the single transaction (LP withdrawal) over two entries so that I can leveragebeancount’s auto-balance feature to calculate the P/L on the ETH and the LP tokens, furthermore forthe sake of simplicity I’m not following my own rule of including the fee in the cost of the output.📉 Margin &amp; Shorting Before proceeding with this section where I show you how I’d account margin &amp; shortingrelated transactions I’d recommend you pause here, and as an exercise try to record your own orexample transactions in beancount or on paper (opening a short, closing, liquidation). Break it downstep by step, what am I putting into this transaction, what am I getting out? What cost basis isassociated? Do my transactions balance and have I forgotten to book income / expenses?Here I’ll talk mainly about margin, leverage and shorting in the sense where you’re actuallyborrowing assets to some degree. If you’re leveraged derivatives such as Perps or Inverse tokensthat don’t directly require debt on your part you can use the approaches described above to accountfor your transactions.Borrowing USDThe first step when leverage trading or shorting is borrowing. Borrowing allows you to basically“play with someone else’s money” paying them back once your trade was successful or degraded to thepoint where the funds are called back, typically in a process called “liquidation”.Thinking of the basics borrowing has two sides: you get something (book to assets) and you create anobligation to pay something back (book to liabilities):2023-01-01 * \"Exchange-A\" \"Borrow 1,000 USD to margin trade\" Liabilities:Margin:Exchange-A -1,000.00 USD Assets:Cash:Exchange-A 1,000.00 USDNow if you trade with those borrowed assets you can book them as normal, buying and sellingdifferent cryptos, tracking the cost basis etc.Repaying USDSimilar to the borrow transaction you simply book the same accounts but in reverse, addinga positive amount to your liabilities and deducting from your asset accounts. To account forinterest you simply book an “interest expense” account:2023-01-01 * \"Exchange-A\" \"Borrow 1,000 USD to margin trade\" Assets:Cash:Exchange-A -1,003.00 USD Liabilities:Margin:Exchange-A 1,000.00 USD Expenses:Interest:Margin:Exchange-A 3.00 USDBorrowing Non-Base Currency AssetsIf you short crypto the old school way or are just borrowing a foreign stable coin ona decentralized lending protocol you’ll have to account your liabilities slightly differently. Sinceyour core ledger is tracked in another asset you may actually realize a loss / gain once you repayyour debt because of a difference in price. Let’s you were shorting LUNA and you borrowed and sold1,000 LUNA at a price of 100 USD / LUNA and you later bought it back and repaid that debt after itdropped to 80 USD, that’d be a gain of 20 USD / LUNA that you have to somehow account. This canachieved by also tracking the “cost basis” of your debt this is nearly identical to what you woulddo for assets although a bit more counterintuitive. The “cost basis” is not the value you spent toacquire the debt but instead the value of the debt when it was created:2022-06-01 open Liabilities:Crypto:Exchange-A \"FIFO\"2022-06-01 open Assets:Crypto:Exchange-A \"FIFO\"2022-06-01 open Expenses:Crypto:Trading-Fees:Exchange-A2022-06-01 * \"Exchange-A\" \"Borrow LUNA for short\" Liabilities:Crypto:Exchange-A -1,000.00 LUNA {100.00 USD} Assets:Crypto:Exchange-A 1,000.00 LUNA {100.00 USD}2022-06-01 * \"Exchange-A\" \"Sell borrowed LUNA\" Assets:Crypto:Exchange-A -1,000.00 LUNA {} Assets:Cash:Exchange-A 99,987.00 USD Expenses:Crypto:Trading-Fees:Exchange-A 13.00 USDNote that liability accounts that track non-base currency assets also need a booking rule as you maybe borrowing in several batches over time at different prices and need to know how to account thevalue change of your debt.Repaying CryptoClosing the LUNA short from above you’d book at 80 USD a transactions as follows:2022-07-01 * \"Exchange-A\" \"Buy Back LUNA\" Assets:Cash:Exchange-A -80,087.00 USD Assets:Crypto:Exchange-A 1,001.00 LUNA {80.00 USD} Expenses:Crypto:Trading-Fees:Exchange-A 7.00 USD2022-07-01 * \"Exchange-A\" \"Repay LUNA loan + 1 LUNA of interest\" Assets:Crypto:Exchange-A -1,001.00 LUNA {} Liabilities:Crypto:Exchange-A 1,000.00 LUNA {} Income:Crypto:Debt-PnL -20,000.00 USD Expenses:Interest:Margin:Exchange-A 80.00 USD // Value of 1 LUNA of interest just bought added to expensesLiquidationLiquidation is nearly identical to repayment except you may have to pay a liquidation penalty on topof the value of the now increased debt, realizing both a loss because of the appreciation of yourliability and expense in the form of the liquidation penalty:; Alternative Universe where LUNA went to 200 USD2022-07-01 * \"Exchange-A\" \"Liquidation at 200 USD / LUNA + 5% penatly and 4 LUNA interest\" Assets:Cash:Exchange-A -210,800.00 USD Liabilities:Crypto:Exchange-A 1,000.00 LUNA {} Expenses:Interest:Margin:Exchange-A 800.00 USD Income:Crypto:Debt-PnL 100,000.00 USD ; 5% on the 200k worth of LUNA debt Expenses:Liquidation:Exchange-A 10,000.00 USDBasic Tax OptimizationNow that we have the tools and some examples to account basically any crypto transaction let’s gothrough some tax tips that should apply to most jurisidictions. However before we dive in I’d referyou to the disclaimer and consulting professionals sections again, this is not tax / legal advicebut merely educational examples of tax strategies that may or may not work or even be legaldepending on where you live and file your taxes. There can be very subtle but important differences betweencountries based on your precise circumstances. Furthermore professional tax advisors and accountantsshould be able to advise on other strategies that are better or actually suited to yourcircumstances.HODL &amp; BorrowUnless your country has some type of wealth / property tax on merely having valuable assets onlyrealized gains are taxed. What this means is that if you buy a coin and it e.g. goes up 1000x overtime turning your $ 10,000 investment into $ 10M that $ 9.99M won’t actually be taxable until yousell those coins for another or fiat. Don’t try to avoid paying taxes by selling your coins for other coins, or spending the tokensdirectly on goods or services via e.g. a crypto card because most jurisidictions count anydisposal as a realization of your gains. Meaning if you pay e.g. for a watch that costs 15k withcoins you purchased at a value of 1.5k you’ll owe the government taxes on the 13.5k realized gain.So great, you have coins that have gone up in value but you can’t / don’t want to sell them to avoidtaxes, what’s the point of having those juicy gains if you can’t spend them, right? Well that’swhere the second part comes in. Instead of selling to access the value of your assets you can borrowagainst them, either on exchanges in the form of margin loans, lending protocols or even directlywith people OTC depending on the asset and what the amount you’re borrowing against is. In mostjurisidictions this doesn’t count as a sale because you technically still own the asset, you’ve justdeposited it somewhere as collateral, as long as you pay the interest and don’t default on the loanyou don’t realize a gain. In fact if you have good collateral you may never have to directly repaythe loan as you could continue to refinance as the value of your asset appreciates.Example:You have 1,000.00 ETH you bought back in the day for $ 20 a piece and you want to get yourself a nice car for$ 60k. Instead of selling that ETH you go to an institution or lending platform and deposit themore than $ 1M worth of ETH as collateral, borrowing $ 60k against it. Not only will you notrealize a gain (again depends on your jurisidiction) the interest on that loan is likely very low anddefinitely much lower than any consumer credit card debt. A win-win.Long-term vs. Short-term GainsExtending the HODL &amp; borrow strategy you can also save a lot in taxes by being aware of yourlong-term vs. short-term profit taxes. You see most jurisidictions have a different tax rate forprofits that are made from assets that were held for shorter periods and profits from assets thatwere held for longer, this is meant to discourage speculation. In Germany for example, short-termgains from crypto held less than 1 year are taxed at your personal income tax rate which veryeasily reaches 42%. However if you hold your crypto for more than a year any gains are completelytax free (doesn’t apply to all coins though and only for private individuals not companies). The USseems to have a similar rule whereby short-term crypto sales count as a “short-term capital gain”and long-term sales count as “long-term capital gain”.3This is why systematically tracking your crypto transactions can be very useful so that you can moreeasily know whether you can decrease your tax burden by simply waiting a bit longer before selling.Tax Loss HarvestingTax loss harvesting is strategy whereby you strategically sell positions at a loss to offset yournet gain for a year and reducing your tax burden. This can be the silver lining in the those shittyNFT and dog coin purchases, they could at least allow you to reduce your taxable gain. Sellingearlier at a loss is also useful because jurisidictions that differentiate between long-term andshort-term gains usually do the same for losses whereby long-term losses are only deductible fromlong-term gains and short-term losses from short-term gains.Example:It’s 2022 and the tax year is ending in 1 month, throughout the year I realized $ 5,000.00 ofshort-term gains taxed at 30% and $ 3,000.00 of long-term gains taxed at 10%. The cutoff forlong-term / short-term is 1 year. I also still hold an NFT that rugpulled right after launch almosta year back, 350 days. At the time I bought the NFT I aped in with ETH that was at the time worth$ 2,000.00. Now there’s no trading volume, no active bids, the project is basically dead, meaninga current value of 0$ or a realized loss of $ 2,000.00 if I were to sell it.If I don’t sell the NFT I’d have to pay 5000 x 30% + 3000 * 10% = $ 1,800.00 in taxes. If I waittoo long to sell the NFT until it’s been a year since the original aquisition it’ll only count against mylong-term gains meaning I’d pay 5000 x 30% + (3000 - 2000) * 10% = $ 1,600.00 in taxes. $ 200.00In savings are good but it could be even better. If I sell the NFT immediately it would just stillcount to my short-term gains, reducing my tax burden to (5000 - 2000) x 30% + 3000 * 10%= $ 1,200.00, $ 600.00 in savings!Beyond simply reducing your tax burden you can also lower the cost basis of the asset if you wish tokeep it by selling and then re-buying it at a similar price, as this will realize a loss and loweryour cost basis because you bought back in at a lower price. Done right this can move losses intoyour short-term gains and move the future gain to your long-term side. Some jurisidictions have rules that prevent you from legally accounting losses if you replaces the asseti.e. buy back-in shortly after you sold it so it is highly advised you do some research beforedoing this. The US for example has a rule that prevents this called the “wash sale” rule thatprevents you from accounting losses for securities such as stocks and bonds that you buy back inless than 30 days.Trading LLC Just create an LLC broAs I briefly touched on before depending on your tax code different types of income may have to beaccounted and taxed differently. What this can for example mean is that if you’re a freelancer gettingpaid in crypto the value upon receival may be taxed as normal income while a realized loss from thecoin itself may only count as capital gains, the may not be able to deduct the one from the other.This is where a “Trading LLC” comes in. In case you didn’t know in almost all jurisidictions ofthe world buisnesses and individuals are taxed differently and have different accounting rules thatapply to them. However you don’t have to have a “real company” to be able to take advantage of thedifferences in rules. In most capitalist countries it’s relatively easy and not that expensive for anyoneto create a buisness entity. A buisness entity is a “virtual” legal person separate from yourself as a privateindividual but controlled by you. Almost how a smart contract is different to an EOA / user wallet.A company is an imaginary concept, it’s a “legal ritual” that has to be enacted by you, typicallytogether with a lawyer or notary that allow to create a new “person” in the legal system. It’s lesscomplicated than it sounds but there are several trade-offs to consider before creating one solelyfor the purposes of trading:Reporting requirements &amp; overheadUnlike your personal income statement filing for a company is usually more complex and expensive thanjust for yourself as it’s typically always done by a professional. This may not always be the case,in some countries it may easier to file taxes for a company than it is to do so privatelyLaws &amp; complianceTrading as a company may require you to get additional licenses from regulatory bodies if it’s a“protected” or “reserved” activity in your country.Finacial separationWhile there are exceptions, buisness entities are typically separate persons with separate financesunder the law so you can’t just freely transfer assets back and forth without certain tax or even legal implications.For example, while a buisness entity may allow you to deduct gains and losses from different incomestreams going into the business from one another, any profits are “stuck” in the company. Legallytaking money out of your business may require you to issue a dividend or salary which will be taxed ascapital gains or normal income, meaning you may end up paying more taxes (corporate tax + capital gains / income tax)than you if you were to just directly trade as private individual.KYCTrading on exchanges and other KYC’ed platforms will also require you to do a separate registration,even more overhead.Final ThoughtsWhile none of us want to pay our taxes the penalty for not doing so or doing so incorrectly can bequite severe. Understanding the basics of financial accounting and your local tax code will allow youto not only pay your taxes and sleep well at night but also give you better insight into yourfinances and finance in general.I hope I was able to present the stereotypically boring subject of accounting and taxation in anengaging and valuable way. If you have any feedback or want to stay updated future finance / smartcontract content you DM / follow me on Twitter. Token Tax - Accounting methods &#8617; Forbes - Article on crypto booking methods &#8617; Investopedia Long-Term vs. Short-Term Capital Gains &#8617; " }, { "title": "Paradigm CTF 2022: Write-Up Collection", "url": "/posts/paradigm-ctf-2022-write-up-collection/", "categories": "ctf-writeups", "tags": "solidity, EVM, security, smart contracts", "date": "2022-08-22 12:36:00 +0200", "snippet": "IntroI participated in the Paradigm CTF 2022 where I was personally able to solve 7 out of the 13 EVM-related challenges (not counting the PVP game 0xMonaco and external underhanded solidity contest). I made a few 0xMonaco cars as well, but at the end we went with the car my teammates made since I was only able to work on mine for a few hours. I did not attempt or look at any of the Cairo / Solana challenges as I felt that I would not be able to do so much in the provided 48h.Shout out to my team the notfellows! 😄Intro - General EVM Challenge StructureFor the 13 EVM related challenges (not counting 0xMonaco, underhanded 2022) the goal was to get the Setup contract’s isSolved method to return true so that the flag could be retrieved from the server. The contracts were deployed to a private chain which was forked off of mainnet. This is an important detail as not all contracts were provided by the CTF, some were just the mainnet contracts which you then had to look at on etherscan.Intro - Write-up LocationsThis post contains technical write-ups of the Hint Finance and Just In Time challenges.Check out the Glossary for links to write-ups of other challenges.Hint Finance 🚩 “Earn rewards without risk by depositing tokens into one of HintFinance’s vaults!” – Hint Finance Challenge DescriptionThe famous last words of many projects.Hint Finance - IntroIn case you’re just looking for the code here’s the full script in foundry.In the Hint Finance challenge the goal was to drain 3 identical vault contracts of at least 99% of their underlying token. While the vaults were identical, the tokens stored in the vaults were different.The vault contract was set up as a typical reward contract whereby you deposit some amount of tokens X in return for vault shares which can be redeemed for your tokens X again, along some rewards in several tokens Y. Besides the deposit and withdraw methods the contracts also had a flashloan method allowing you to borrow any token the vault holds.There were also a couple of methods related to rewards but I quickly realized that those were just distractions as you have no way of setting the reward tokens and all the configured reward tokens were not the actual target tokens you’re looking to drainHint Finance - Initial Ideas 🤔Initially I looked at the flashloan method trying to find a way to deposit/withdraw during the loan but due to its design I had to conclude that this was not possible. This is because the flashloan method enforces not only that the tokens be returned but also that the amount of total outstanding vault shares remain constant. This means you can’t keep new shares, have existing shares be redeemed or otherwise mess with the share price besides increasing it by returning more tokens than necessary.Hint Finance - ERC777 Does It Again 😬After my initial look I remembered that the contracts are forked off mainnet and decided to check their code. There I discovered that 2 of the 3 target tokens were ERC777 tokens. ERC777 tokens are token contracts which are backwards compatible with ERC20 but implement added functionality based on the ERC777 standard. Most importantly the standard specifies that a token’s transfer / transferFrom methods must function as follows (excluding allowance logic): Call the sender’s pre-transfer hook if one is registered Change balance of sender, reciepient Call the sender’s post-transfer hook if one is registered Upon discovering that the 2 tokens were ERC777 tokens I went to check the obvious vulnerability that came to mind, thinking “surely it couldn’t be this straight forward”. I looked at the withdraw and deposit methods and checked whether I could leverage the pre-/post-transfer hooks to somehow exploit the vault:function deposit(uint256 amount) external updateReward(msg.sender) returns (uint256){ uint256 bal = ERC20Like(underlyingToken).balanceOf(address(this)); uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / bal; ERC20Like(underlyingToken).transferFrom( msg.sender, address(this), amount ); totalSupply += shares; balanceOf[msg.sender] += shares; return shares;}function withdraw(uint256 shares) external updateReward(msg.sender) returns (uint256){ uint256 bal = ERC20Like(underlyingToken).balanceOf(address(this)); uint256 amount = (shares * bal) / totalSupply; ERC20Like(underlyingToken).transfer(msg.sender, amount); totalSupply -= shares; balanceOf[msg.sender] -= shares; return amount;}Looking at the deposit method you only get control via the pre-transfer hook. This is not useful as the logic for updating the token balance and issuing new shares happens after the hook is complete, oustside of your control.The withdraw method is the jackpot however as you get the control-flow via the post-transfer hook, after the balance was changed but before your share balance is updated. Let’s break it down with an example where we withdraw everything to illustrate: Step Vault Balance Your Balance Total Shares Your Shares Share Price Before withdraw call 100.00 0.0 100.0 50.0 1.0 Start of post-transfer hook 50.00 (-50) 50.0 (+50) 100.0 50.0 0.5 Contract reduces share balance 50.00 50.0 50.0 (-50) 0.0 (-50) 1.0 After call: 50.00 50.0 50.0 0.0 1.0 As you’ll notice there’s a temporary dip in share price at the point where we take over the control-flow. We can “buy the dip” we artificially create by depositing back into the vault: Step Vault Balance Your Balance Total Shares Your Shares Share Price Before withdraw call 100.00 0.0 100.0 50.0 1.0 Start of post-transfer hook 50.00 (-50) 50.0 (+50) 100.0 50.0 0.5 After buying shares deposit(50.0) 100.00 (+50) 0.0 (-50) 200.0 (+100) 150.0 (+100) 0.5 Contract reduces share balance 100.0 0.0 150.0 (-50) 100.0 (-50) 0.667 After call: 100.0 0.0 150.0 100.0 0.667 Result is we were able to mint shares “out of thin air”, diluting the other depositors and allowing us to redeem more tokens. If we repeat this a couple times we’ll eventually own 99%+ of the shares and be able to drain the 2 ERC777 (PNT, AMP) tokens from the vault.I’m not going to detail the implementation of a ERC777 based reentrancy attack, as it’s a fairly common thing but you can view my exploit script here if you’re interested in the implementation details.Hint Finance - The Final Token, How????!!! 😡After the first 2 tokens were relatively straight forward I started wondering how I was gonna approach the last one, SAND (ID: 1). Its transfer methods had no strange hooks, the contract file names didn’t seem to advertise any unusual standards being implemented so what can I do?Well I went back to the vault contract and made an inventory of all the potential external calls I could somehow use: transferFrom in provideRewardTokens(...) (only transfers rewards in) transfer in getRewards(...) (only transfers specific reward tokens out) transferFrom in deposit(...) (only transfers in tokens) transfer in withdraw(...) (transfers out but only exploitable with reentrancy) transfer in flashloan(...) (transfers out but cannot keep tokens) onHintFinanceFlashloan in flashloan(...) (triggers flashloan callback) several balanceOf (view method, meaning staticcall used under the hood)Hmmm 🤔, there seems to be only two possibilities left: either I’m wrong about one of the other paths or the selector of the weirdly named onHintFinanceFlashloan method collides with another useful method. This is possible because the ABI spec says that selectors have to be the first 4-bytes of the function signature.So I calculated the selector of onHintFinanceFlashloan, 0xcae9ca51 and put it in 4byte.directory, a database of function signatures and their selectors. Note that when I looked at 4byte during the challenge onHintFinanceFlashloan was not yet uploaded.I was right, not only is there an alternative function but it was already uploaded to 4byte (I could’ve been searching much longer if I had to check it manually) and it was also present on the token contract: the approveAndCall(...) method! This is exactly what I needed, if you craft the call payload well the vault will simply approve some address you create to spend tokens on its behalf and the tokens will be mine 🤑.Hint Finance - Flexible ABIBefore doing a victory lapse we actually have to exploit this vulnerability which is not that trivial. Let’s look at the flashloan method as a whole:function flashloan( address token, uint256 amount, bytes calldata data) external updateReward(address(0)) { uint256 supplyBefore = totalSupply; uint256 balBefore = ERC20Like(token).balanceOf(address(this)); bool isUnderlyingOrReward = token == underlyingToken || rewardData[token].rewardsDuration != 0; ERC20Like(token).transfer(msg.sender, amount); IHintFinanceFlashloanReceiver(msg.sender).onHintFinanceFlashloan( token, factory, amount, isUnderlyingOrReward, data ); uint256 balAfter = ERC20Like(token).balanceOf(address(this)); uint256 supplyAfter = totalSupply; require(supplyBefore == supplyAfter); if (isUnderlyingOrReward) { uint256 extra = balAfter - balBefore; if (extra &gt; 0 &amp;&amp; token != underlyingToken) { _updateRewardRate(token, extra); } } else { require(balAfter == balBefore); // don't want random tokens to get stuck }}The flashloan method calls the caller, not necessarily the token directly meaning we need the token to be the caller somehow and give the vault a specific payload. Thankfully we can just leverage approveAndCall again, approving the vault and calling the flashloan method.There’s a few more tricky bits I had to find out while debugging my exploit as the two colliding methods have different parameters. Let’s breakdown the calldata that the vault creates when calling onHintFinanceFlashloan:cae9ca51 // selector0x00: &lt;32-byte padded address&gt; // vault: token, SAND: target0x20: &lt;32-byte padded address&gt; // vault: factory, SAND: amount0x40: &lt;32-byte uint&gt; // vault: amount, SAND: data.offset0x60: &lt;32-byte padded bool&gt; // vault: isUnderlyingOrReward, SAND: ?0x80: &lt;32-byte padded byte-string offset (0xa0)&gt; // vault: data.offset, SAND: ?0xa0: &lt;32-byte padded byte-string length&gt; // vault: data.length, SAND: ?0xc0..X: &lt;byte-string&gt; // vault: data, SAND: ?Firstly the recipient of the approval will be the token. This means that we can’t directly be the recipient of the approval because solidity will revert if you try to call methods like balanceOf or transfer on an EOA. So I created a custom contract to execute the exploit which had some methods so that it can pretend it’s an ERC20 token:function transfer(address, uint256) external returns (bool) {\t// just needs to not revert\treturn true;}function balanceOf(address) external view returns (uint256) {\treturn 1e18; // constant for the sake of simplicity}Next you’ll notice that the approve amount that the token contract receives will be the address of the factory. Considering the token has 18 decimals and an address is about ~1e30 when interpreted as a number that’ll be more than enough to drain the contract in one go.A further aspect is that amount can’t be just anything. If it’s 0 and points at an address it’ll imply such a large byte-string that approveAndCall will just revert when it tries to copy it from calldata to memory. Instead we set it to 0xa0 so that when approveAndCall tries to get the data it’ll find the data provided by the vault.Another error I got is \"first param != sender\" from the token contract, this is because the approveAndCall method enforces that the data has a minimum length and that the first argument is the caller’s address. To ensure the correct length and address I set the return payload of the nested call to approveAndCall to be:bytes memory innerPayload = abi.encodeWithSelector(\tbytes4(0x00000000),\t_sandVault,\tbytes32(0),\tbytes32(0),\tbytes32(0));The selector is 0x00000000 for simplicity so I add an empty fallback method to my exploit contract so it accepts the final call.Finally I just nest the calls and use transferFrom to transfer the tokens out of the vault. You can view my full solution here.Hint Finance - ConclusionThe Hint Finance challenge reminds us that we should always be wary of external calls to user controllable addresses and that you should always assume that ERC20 tokens can reenter upon transfers, just like ETH.Just In Time (JIT) 🚩JIT - IntroIn case you’re just looking for the code here’s the full script I wrote to solve the challenge. Considering that only 5 others solved it I am particularly proud of having solved this one. Especially since I really struggled with it:But after an estimated ~16h of struggle my perceverance paid off and I managed to conquer the challenge!In the Just-In-Time challenge (referred to as JIT for the remainder) the condition for receiving the flag, was draining the provided JIT contract of ETH. The JIT contract performs some logic around a provided input program, compiling it to EVM bytecode, subsequently deploying it and then delegate calling it. DELEGATECALL Unlike a normal call, when a contract delegate calls to another it gives it complete control allowing it to modify storage, emit events, call other contracts, transfer ETH and even self destruct on its behalf. While useful for libraries, proxies and complex patterns like ERC-2535 Diamonds, it can open up a lot of attack surface. For more details refer to evm.codes or theEthereum Yellow PaperJIT - Compiler Structure 🧱If we’re going to give this JIT compiler a program that’ll compile to malicious code we’ll have to first understand it. Skimming over the contract and reading the comments we can identify 6 modules / steps: Loop finder: Finds and matches square-brackets [] Block finder: Based on the loops splits the program into discrete “blocks” that can be jumped to Optimizer: Shortens repetitive / inefficient program segments Code generator: Generates the main meat of the code, translating jit symbols into EVM bytecode and keeping track of where blocks start and end in the bytecode. Label filler: Inserts the actual jump locations into the code. Deployer: Inserts the code length into the constructor, deploys and executes the codeSide note: Looking at the basic set of symbols [],.+-&lt;&gt;, the “jit language” seems to be a super set of Brainfuck, a minimalistic, turing complete language.JIT - Desired CodeBefore we trick the compiler into generating malicious code we need to ask ourselves what that code should look like so that we know what we’re aiming for. There’s a relatively small set of opcodes that would allow us to transfer out ETH: CREATE , CALL, CALLCODE, DELEGATECALL, CREATE2 and SELFDESTRUCT.From all these operations SELFDESTRUCT seems to be the best candidate as it only consumes 1 stack element and automatically transfers all ETH, especially useful considering how constrained the compiler is. The precise recipient is irrelevant as our sole win condition is to drain the compiler, making our goal: have the code reach a SELFDESTRUCT opcode with at least 1 element on the stack.JIT - Getting Our Code In 🕳️Working backwards we can look at the code generator and see that the only opcodes it directly inserts are: SWAPs, PUSHs, MLOAD, MSTORE, JUMPDEST, JUMP, JUMPI, ADD, SUB, CALLDATALOAD, DUPs, SHR and LOG0.However there is a single section that inserts user defined bytes into the final result. However with heavy restrictions. If the parser doesn’t recognize a byte in the program it’ll insert it directly into the code, wrapped in invalid opcodes:// jit.compile isn't actually provided in the challenge, I simply split the invoke method for testingjit.compile(\"+-\\xff\");Results in:630000001c80600e6000396000f3 (constructor)6000618000 (contract header, sets up stack)5b (JUMPDEST, block start)80516001018152 (\"+\")8051600190038152 (\"-\")deadffbeef (0xff wrapped in invalid opcodes)5b00 (contract footer, JUMPDEST STOP)This presents the major issue that whatever opcode we place in the middle is not reachable. It can’t be reached linearly because of the invalid opcodes in front and it can’t be jumped to because the EVM requires a JUMPDEST at the location where a jump (JUMP / JUMPI) lands, meaning we actually need to insert at least 2 bytes somehow: 5bff (JUMPDEST, SELFDESTRUCT).There are other compiler sections that insert custom bytes but only ever after PUSH opcodes meaning they aren’t interpreted as their opcodes but as data.JIT - Breaking The Wrapper ⛏️Note that we can put any opcode in the wrapper as long as its byte value doesn’t overlap with one of the recognized jit symbols ([],.&lt;&gt;+-RLAS0#), we can even insert a PUSH opcode into the wrapper. What’s interesting about the PUSH opcode here is that it’s not an isolated opcode, the bytes following a PUSH get pushed on the stack, so they’re not interpreted as functional opcodes but data.While this still doesn’t allows us to reach the code it does allow us to change the meaning of subsequent code. As an example imagine the following EVM code:INVALID INVALID [SELFDESTRUCT] INVALID INVALID PUSH2 0x5bff de ad ff be ef 61 5bffNow, placing a PUSH3 in the invalidity wrapper:INVALID INVALID PUSH3 0xbeef61 JUMPDEST SELFDESTRUCT de ad 62 beef61 5b ffThe bytes 5bff that were previously treated as data to be pushed, are all of a sudden malicious code!Note in the actual JIT compiler we use the A / S symbols to insert the 2-bytes, which also inserts added opcodes before its PUSH2 which is why my final solution uses PUSH5 (0x64).JIT - Reaching The WrapperWe’ve figured out how to insert some malicious code but now we actually need to jump to it. Looking at the loop finder, block finder and label filler modules they seem quite robust, they only ever insert jump labels that jump between the edges of blocks, which are at the program’s square brackets.Thankfully we can insert a custom jump location by leveraging 3 bugs in the compiler: The loop linking mapping loops is not reset between calls The block to code position mapping basicBlockAddrs is also not reset between calls Unmatched open-brackets [ are allowed and do not reset their loop valuesMatched square brackets are safe because when they’re found their respective links are reset. However for unmatched square brackets the block finder still queries the loops mapping allowing us to use values set in previous calls.JIT - Tying It All Together 🎁Now that we know how to exploit the contract we need to implement the exploit, while it’s relatively straight forward once you know how, getting the precise positions right is a bit finicky.I started with the final program, inserting some padding # to ensure that I had enough space to set the necessary values in prior calls: [################\\x64S\\x5b\\xff. I then compiled with JIT to see where the location of the critical JUMPDEST was. I then crafted 2 pieces of JIT code one setting the value in the basicBlockAddrs mapping and the other in loops. It’s likely possible to do it in 1 instead of 2 pre-solution programs but for simplicity’s sake I just did it in 2 as it was easier.Despite all the effort the above work condenses down to the following small solution:// SPDX-License-Identifier: GPL-3.0-onlypragma solidity ^0.8.13;import \"forge-std/Script.sol\";import {Setup, JIT} from \"src/public/contracts/Setup.sol\";contract ExploitJIT is Script {\tfunction setUp() public {}\tfunction run() public {\t\tvm.startBroadcast();\t\tSetup s = Setup(vm.envAddress(\"SETUP_ADDR\"));\t\tJIT jit = s.TARGET();\t\tjit.invoke(\"[#######################]\", \"\");\t\tjit.invoke(\"########################[]\", \"\");\t\tjit.invoke(\"[################\\x64S[\\xff\", \"\");\t\tvm.stopBroadcast();\t}}JIT - ConclusionJust-In-Time shows us that simplicity is king and that you should avoid using storage mappings for on the fly calculations. Not only is it vulnerable but it costs a lot of gas!This challenge also taught me that I should never give up and always look for stupid stuff I missed. I was stuck for several hours because I missed the fact that JIT used mappings for certain critical data structures and didn’t take precautions to reset them in-between calls. Making a detailed list of assumptions I had and checking them could’ve helped me discover this sooner.GlossaryThe following is a breakdown of the Paradigm CTF 2022 with links to respsectivewrite-ups. Challenges are sorted by total solves. Credit to 0xfoobar’s thread for links to some of the write-ups. ✅ Means personally solved (for 0xMonaco just means participated) ❌ Did not solveEVM (Solidity) Challenges: ✅ 0xMonaco (meta thread, winning car by 0age, thread 1) ❌ Solidity Underhanded 2022 ❌ Fun Reversing Challenge ❌ Stealing Sats ❌ Electric Sheep ✅ Just-in-Time ❌ Trapdoooor ✅ Hint Finance 🏅 (I got first blood) ❌ Trapdooor ❌ Lockbox 2 (Stage 4 &amp; 5) ✅ Vanity ✅ Sourcecode ✅ Merkledrop ✅ Rescue ✅ RandomSolana Challenges: ❌ Solhana 3 ❌ Solhana 2 ❌ Solhana 1 ❌ Otter Swap ❌ Otter WorldCairo Challenges: ❌ Cairo Auction ❌ Cairo Proxy ❌ Riddle Of The SphinxFound a grammar, spelling or factual error or would like to suggest an improvement? Feel free toraise an issue or reachout to me on twitter." }, { "title": "Constant Gas Function Dispatchers in the EVM", "url": "/posts/selector-switches/", "categories": "smart-contract-development", "tags": "solidity, EVM, smart contracts, development", "date": "2022-03-16 18:55:00 +0100", "snippet": "Image: Telecom switchboard operator1IntroEvery2 smart contract on Ethereum and other EVM chains starts with its function dispatcher.Function dispatchers tell the contract whether they’ve implemented the requested method and wherethe code for that method is found within the contract. I’ll also refer to functiondispatchers as “selector switches” as they remind of Telecom switchboard operators and are similarto switch-statements of common programming languages.Function dispatchers are executed upon every contract call meaning inefficiencies &amp; optimizations inthis area of the code will impact all calls and the general gas efficiency of the contract. The moststraightforward approaches to function dispatchers employed by high-level languages like Solidity and Vyperand even taught in the Huff tutorial on function dispatchingare however not as optimal as they could be.This post will look at the common approaches to function dispatchers and show more optimal versionsyou can apply to your low-level contracts. This post also assumes some familiarity with the EVM andits opcodes (low-level EVM instructions); if you need a quick intro I’d recommend Huff’s“Understanding the EVM” Tutorial section as itgives a good overview of how the EVM works.This post will look at different ways to build function dispatchers and the different tradeoffsI considered when I built the highly optimized function dispatcher for the improved Wrapped Etherimplementation METH that I’m working on.Refresher: What Are Selectors?Selectors are standardized 4-byte identifiers used to identify methods across contracts. Functionselectors are the left 4-bytes of the keccak hash of a function’s signature. Since the data typesof the parameters are also hashed this allows contracts to differentiate between functions that havethe same name but different sets of parameters like the safeTransferFrom methods in ERC721tokens. One thing to watch out for is selector collisions, these can occur because the selectoris only the first 4 bytes of the actual hash, they are quite rare however, occurring mainly in CTFs.You can see an example of vulnerability arising from a selector collision in my write-up of theParadigm CTF 2022 “Hint Finance” challenge.Selector ExampleFunction:function withdraw(uint256 amount) external { // ...}Signature: withdraw(uint256)Selector:keccak256(\"withdraw(uint256)\")[0:4] =&gt;0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f =&gt;0x2e1a7d4dCall to withdraw(1e18):selector: 0x2e1a7d4damount (1e18): 0x0000000000000000000000000000000000000000000000000de0b6b3a7640000----------------------------------------------------------------------------------------calldata: 0x2e1a7d4d0000000000000000000000000000000000000000000000000de0b6b3a7640000The precise specification of how selectors are defined and computed can be found in theContract ABI Specification, it specifieshow arguments are encoded and some more precise details when it comes to actuallycomputing the selector for different types. If you’ve installed the foundry smart contract developmentframework using foundryup you should have the cast tool installed which lets you easily getthe selector of any method by running cast sig &lt;your function&gt; e.g. cast sig \"withdraw(uint)\"results in 0x2e1a7d4dHaving a common standard for selectors is extremely useful as it lets different contracts easilyinteract with each other without having to look up and implement some custom data and functionencoding scheme for every contract. It also allows higher-level languages to offer some abstractionin the form of public / external methods.Micro Huff CrashcourseSince I’ll be denoting opcode snippets using Huff in this post I’ll do an extremely brief intro toHuff, you can find a full list of Huff’s features here:docs.huff.sh/get-started/huff-by-example/.What is Huff?: Huff is a low-level assembly language for the EVM, it’s basically just mnemonicbytecode (bytecode but written as aliases “SLOAD”, “DUP1” rather than the byte values) with somesyntactic sugar around selectors, constants and jump destinations to improve the developerexperience.Opcodes:Opcodes in Huff are written in their mnemonic i.e. “word form” and can be upper / lower case. Theonly exceptions are the PUSH1 - PUSH32 opcodes. For these, the values can be written directly inhexadecimal and the compiler will find the shortest fitting push opcodes for them e.g. 0x3212compiles to PUSH2 0x3213 (0x613213). Huff also allows for constants which are defined by#define constant CONSTANT_NAME = 0x&lt;constant value&gt; and are referenced by square brackets e.g.[PERMIT_TYPEHASH] and are also compiled to PUSH opcodes.Jump Labels &amp; Destinations:Jump labels are a convenient way to manage jumps without having to manually recalculate alldestinations every time a bit of code is changed. Destinations are defined by &lt;name_of_label&gt;: e.g.withdraw_start:, the compiler will insert the 1-byte JUMPDEST opcode at all labels, whetherthey’re referenced or not. Jump destinations can be pushed to the stack by just writing their label:withdraw_start, Huff will currently always use a PUSH2 opcode even if the destination onlyrequires 1 byte.Macros:Macros are kind of like functions in higher-level languages. They’re bits of code you can reuseand are inserted inline by the compiler whenever referenced. They can also have static argumentswhich are also inserted at compile time. Within the macro, static arguments are referenced by angledbrackets and the name of the argument e.g. &lt;zero&gt;. Macro arguments can be static values, jumplabels or opcodes.Other features:Huff has a few other features like fn macros, tables, helper functions and even a way to definetests but I won’t be using most of them for this post outside of tables which I’ll introduce once westart using them. You can check out the extra features with the above link to Huff’s “Huff by example”section. Because Huff is so essentially mnemonic opcodes with bells and whistles I’ll also be using it toillustrate theoretical compiler output in a more human-readable way.Common Function DispatchersThe goal of a function dispatcher is to: Load the selector from calldata Reverts for non-matching selectors Jump to the section of bytecode that executes the logic for that functionLinear If-Else Dispatcher“Linear If-Else Dispatcher” are the most straightforward and common dispatcher, generated by Solidity,Vyper and even presented in Huff’s tutorial. While the precise structure and opcodes used betweenthe languages differ, an efficient Huff implementation and very similar to actual output from theSolidity compiler could look something like this:/*loads bytes 0-31 of calldata and shifts right by 28 bytes to get the 4-byte selector(28 bytes = 28 * 8 bits = 0xe0 in hexadecimal)*/// In Huff it's a common convention to denote the state of the stack in a comment on every line0x0 calldataload 0xe0 shr // [call_selector] // 1st If-Else Block// Copy selector from stackdup1 // [call_selector, call_selector]// Place selector on stack0x01020304 // [function_selector, call_selector, call_selector]// Compare, are they eq-ual?eq // [function_selector == call_selector, call_selector]// Place function destination on stack in case they matchfunction1_dest // [function_dest, function_selector == call_selector, call_selector]// Conditional jump, will jump if the result from `eq` was true (1)jumpi // [call_selector]// If selectors didn't match `jumpi` will not jump and the code will continue here// Next if-else blocksdup1 0x05060708 eq function2_dest jumpidup1 0x11223344 eq function2_dest jumpi...// if no match just revert0x0 0x0 revertShown as a diagram the control flow progresses step by step through every else-if “block” untila matching selector is identified or the end of the switch is reached, in which case it results ina revert:This approach makes for a decent selector switch, it can easily be generated for any contractregardless of its selector set and count and fulfils our requirements of a selector: It loads the selector from calldata Reverts if nothing matched It does a direct comparison with all selectors until it finds one, won’t jump unless there’sa 1:1 matchHowever, this approach is far from efficient because the average gas use (assuming the functions arerandomly ordered in the switch and all used equally) grows linearly with the number of functions.Assuming we’re considering the gas use as run-time complexity this would have a time complexity of$O(n)$ in classic CS big-O notation. This is fine and quite efficient for contracts with ~3-6functions but quickly loses ground to alternative approaches as the number of functions grows.Usage based optimization:Without changing the fundamental approach we can optimize the average gas use by reordering theswitch, putting more commonly used functions first. This will allow common calls to go through fewerif-else blocks to find their match, improving average gas performance. The problem with thisoptimization is that there’s no real way to tell the compilers of high-level languages like Solidity/ Vyper your selector-order preference and you need to anticipate the average use of your contractwhich can be tricky. A practical example of this is in SeaPort, where a function name was minedsuch that its selector was 0x00000000 and therefore placed earlier in the function dispatcher.3Binary Search DistpachersThe binary search based selector switch is much more efficient than the simpler linear else-ifswitch for contracts with more functions. This is achieved by structuring the switch like a binarysearch tree, eliminating half the possible selectors at every step. This makes the time complexitylogarithmic, $O(\\log n)$:Intuitively we can see that the average gas cost of reaching any given method in the contract growslogarithmically relative to the number of selectors because we can double the number of supportedselectors while just adding a constant size step on the path to every selector:(click to expand)Instead of 2 x “Split” and 1x “If-Else” branches, you need to traverse 3x “Split”and 1x “If-Else” branch to reach any given function. If the amount of functions is not a power of2 the tree approach will still work but the number of branches required to reach a given functionwill vary.But how does it work exactly? How are you able to eliminate half the possible functions at everystep?Like a binary search tree for integers, you can create one for the selectors of the functionsand then compare them with some middle value at every node. This is possible because the EVM has nonotion of datatypes, it doesn’t differentiate between strings, unsigned integers, signed integers,booleans, selectors or jump labels. To the EVM opcodes, all values on the stack are 256-bit words,that can be added, subtracted and compared, against each other. To create our selector binarysearch tree we first need to interpret the 4-byte selectors as integers and sort them:0x06fdde03 // name()0x095ea7b3 // approve(address,uint256)0x18160ddd // totalSupply()0x205c2878 // withdrawTo(address, uint256)0x23b872dd // transferFrom(address,address,uint256)0x2e1a7d4d // withdraw(uint256)0x313ce567 // decimals()0x3644e515 // DOMAIN_SEPARATOR()0x4a4089cc // withdrawFromTo(address, address, uint256)0x70a08231 // balanceOf(address)0x7ecebe00 // nonces(address)0x87f8ab26 // depositAmount(uint256)0x9470b0bd // withdrawFrom(address, uint256)0x95d89b41 // symbol()0xa9059cbb // transfer(address, uint256)0xac9650d8 // multicall(bytes[])0xb2069e40 // depositAmountTo(address, uint256)0xb760faf9 // depositTo(address)0xd0e30db0 // deposit()0xd505accf // permit(address, address, uint256, uint256, uint8, bytes32, bytes32)0xdd62ed3e // allowance(address, address)You then continuously split the list of selectors in halves, saving the midpoints as you go along,so that you can construct the tree: 0x06fdde03 // name() 0x095ea7b3 // approve(address,uint256) &lt;---- Split 1_1_1 0x10000000 0x18160ddd // totalSupply() 0x205c2878 // withdrawTo(address, uint256) &lt;---- Split 1_1_1_2 0x23000000 0x23b872dd // transferFrom(address, address, uint256) 0x2e1a7d4d // withdraw(uint256) &lt;---- Split 1_1 0x30000000 0x313ce567 // decimals() 0x3644e515 // DOMAIN_SEPARATOR() &lt;---- Split 1_1_2 0x40000000 0x4a4089cc // withdrawFromTo(address, address, uint256) 0x70a08231 // balanceOf(address) 0x7ecebe00 // nonces(address)&lt;---- Split 1 0x80000000 0x87f8ab26 // depositAmount(uint256) 0x9470b0bd // withdrawFrom(address, uint256) &lt;---- Split 1_2_1 0x95000000 0x95d89b41 // symbol() 0xa9059cbb // transfer(address, uint256) 0xac9650d8 // multicall(bytes[]) &lt;---- Split 1_2 0xb0000000 0xb2069e40 // depositAmountTo(address, uint256) 0xb760faf9 // depositTo(address) &lt;---- Split 1_2_2 0xc0000000 0xd0e30db0 // deposit() 0xd505accf // permit(address, address, uint256, uint256, uint8, bytes32, bytes32) 0xdd62ed3e // allowance(address, address)The code then compares the selector to the mid value to see if it should jump left or right at everypoint: Smol Optimization Tip Depending on the context within the code you can save gas by replacing 0x00 (which compiles toPUSH1 0x00 and costs 3 gas) with other opcodes that cost 2 gas and return 0x00: PC (program counter): Returns 0 if it’s the very first byte of your contract RETURNDATASIZE: Returns 0 until your contract has called another contract and the return/ revert data was at least 1 byte long at which point it’ll return the length in bytes of thatreturned data CALLVALUE: Returns 0 if no ETH was sent along with the call, if you’ve already done a call value check(assert(msg.value == 0)) you can rely on the CALLVALUE opcode to always return 0 until theend of the call. MSIZE (memory size): Returns 0 as long as you haven’t used memory yet Note that this is no longer necessary on chains with the Shanghai upgrade as you can just use thePUSH0 opcode which will always cost 2 gas and push 0 onto the stack regardless of context.// -- Get 4 byte selectorpc calldataload 0xe0 shr // [selector]// -- Split 1// Copy selectordup1 // [selector, selector]// Push split value of split 10x80000000 // [split_1_val, selector, selector]// Compare selector to split value.lt // [split_1_val &lt; selector, selector]// Prepare split 1_2 dest in case branching off.split_dest_1_2 // [split_dest_1_2, split_1_val &lt; selector, selector]// Jump to split 1_2 if comparison succeededjumpi // [selector] // Split 1_1 dup1 0x30000000 lt split_dest_1_1_2 jumpi // Split 1_1_1 dup1 0x10000000 lt split_dest_1_1_1_2 jumpi // Split 1_1_1_1 dup1 0x06fdde03 eq name_dest jumpi dup1 0x095ea7b3 eq approve_dest jumpi returndatasize returndatasize revert split_dest_1_1_1_2: // Split 1_1_1_2 dup1 0x23000000 lt split_dest_1_1_1_2_2 jumpi // Split 1_1_1_2_1 dup1 0x18160ddd eq totalSupply_dest jumpi dup1 0x205c2878 eq withdrawTo_dest jumpi returndatasize returndatasize revert split_dest_1_1_1_2_2: // Split 1_1_1_2_2 dup1 0x23b872dd eq transferFrom_dest jumpi dup1 0x2e1a7d4d eq withdraw_dest jumpi returndatasize returndatasize revert split_dest_1_1_2: // Split 1_1_2 dup1 0x40000000 lt split_dest_1_1_2_2 jumpi // Split 1_1_2_1 dup1 0x313ce567 eq decimals_dest jumpi dup1 0x3644e515 eq DOMAIN_SEPARATOR_dest jumpi returndatasize returndatasize revert split_dest_1_1_2_2: // Split 1_1_2_2 dup1 0x4a4089cc eq withdrawFromTo_dest jumpi dup1 0x70a08231 eq balanceOf_dest jumpi dup1 0x7ecebe00 eq nonces_dest jumpi returndatasize returndatasize revertsplit_dest_1_2: // Split 1_2 dup1 0xb0000000 lt split_dest_1_2_2 jumpi // Split 1_2_1 dup1 0x95000000 lt split_dest_1_2_1_2 jumpi // Split 1_2_1_1 dup1 0x87f8ab26 eq depositAmount_dest jumpi dup1 0x9470b0bd eq withdrawFrom_dest jumpi returndatasize returndatasize revert split_dest_1_2_1_2: // Split 1_2_1_2 dup1 0x95d89b41 eq symbol_dest jumpi dup1 0xa9059cbb eq transfer_dest jumpi dup1 0xac9650d8 eq multicall_dest jumpi returndatasize returndatasize revert split_dest_1_2_2: // Split 1_2_2 dup1 0xc0000000 lt split_dest_1_2_2_2 jumpi // Split 1_2_2_1 dup1 0xb2069e40 eq depositAmountTo_dest jumpi dup1 0xb760faf9 eq depositTo_dest jumpi returndatasize returndatasize revert split_dest_1_2_2_2: // Split 1_2_2_2 dup1 0xd0e30db0 eq deposit_dest jumpi dup1 0xd505accf eq permit_dest jumpi dup1 0xdd62ed3e eq allowance_dest jumpi returndatasize returndatasize revertUnlike the diagram, you’ll notice that I didn’t create split branches all the way down, but insteadput small linear switches at the end once only 2-3 functions were left in the split. This is becausea split branch can only cut the range of selectors in half but cannot confirm whether the selectormatches exactly, you need a directly comparing “if-else” branch at the end of your tree. If yousplit your selectors until each split only contains 1 selector the last split is redundant:// Split branch cost: 22 (+1 for jump dest on the `_2` branch)// If-else branch cost: 22// Split until only 1 Selector leftsplit_dest_x: dup1 0xd2000000 lt split_dest_x_2 jumpi // Split x_2 dup1 0xd0e30db0 eq deposit_dest jumpi (y + 44 gas to reach) split_dest_x_2: // Split x_2 dup1 0xd505accf eq permit_dest jumpi (y + 45 gas to reach, includes 1 gas for `JUMPDEST`)// Linear if-else for 2 functions:split_dest_x: dup1 0xd0e30db0 eq deposit_dest jumpi (y + 22 gas to reach) dup1 0xd505accf eq permit_dest jumpi (y + 44 gas to reach)Similar reasoning applies to a split with 3 selectors. Further splitting a split with 3 selectorsleft turns the cost of (22, 44, 66) =&gt; (45, 66, 67). In fact, if you take the average gas use of thedifferent selectors it doesn’t even make sense to break up a split containing 4 selectors: (22, 44,66, 88; avg: 55) =&gt; (44, 66, 45, 67; avg: 55,5). Meaning that my example is not even a perfectly optimalbinary search switch.The Solidity compiler will automatically create such binary search switches once you have sufficientfunctions to justify the cost. Unfortunately, this is where we meet the limits of existing high-levelcompilers in terms of selector switch generation, to squeeze more gas out of our contracts we mustdive deeper, into the dark depth of opcode-level optimization, but don’t worry it’s less intimidatingthan it sounds.⚡Constant Gas SwitchesConsidering that the generated binary search switches are already optimal in terms of opcode usewe need a completely different approach if we’re going to improve the gas cost of existing selectorswitches. To do that we’ll target the theoretically optimal time complexity of $O(1)$ meaning thecost of our selector switch doesn’t grow at all relative to the number of selectors.While $O(1)$ is theoretically optimal we’ll also have to make sure the constant amount of gas used is actuallycheaper than an alternative binary search or linear if-else switch. This is important because a naive$O(1)$ switch would e.g. be to store all jump destinations of the different functions in storagemapping-type data structure and load them when the contract gets executed, while this would use aconstant amount of gas regardless of how many functions you have because it only needs a singleSLOAD, the cost of that operation (2100) would make it more expensive than nearly any alternative.🧱 Base CostWhenever I work on gas optimization I like to determine or at least approximate how efficienta solution could theoretically be. For gas cost this is usually down to what you need the code to doand what you’re working with. In general, when building a selector switch there are two pieces that cannotbe avoided: Isolating the selector from calldata: &lt;zero push&gt; calldataload + [PUSH1 0xe0 SHR / PUSH32 0xffffffff00000000000000000000000000000000000000000000000000000000 AND] (11 gas, assuming the zero-push is a 2 gas opcode such as PC, RETURNDATASIZE or PUSH0 itself) Checking if the selector is an exact match: PUSH4 &lt;expected_selector&gt; [eq / sub] PUSH1/2 &lt;code / revert dest&gt; JUMPI (19 gas)So we can confidently say that no ABI compliant selector switch, that reverts upon unmatchingselectors can cost less than 30 gas. In fact, exactly 30 gas is possible when your contract has exactly1 selector:// Load selectorpc calldataload 0xe0 shr// Use subtraction opcode `SUB` as \"not equals\" comparison. If selectors don't match// subtraction result will be non-zero and cause `JUMPI` to jump to the revert&lt;single_selector&gt; sub no_match_error jumpi// Huff macro that will insert the function's codeSINGLE_FUNCTION()no_match_error: returndatasize returndatasize revert // pushes 2 zeros and then revertsConstant-lookup Data StructuresWhen it comes to looking up data based on some key in constant time the two main data structuresthat come to mind are arrays and hash maps. Since the EVM does not offer a native map / array opcode(yet), we’ll look at different ways we can build thesedata structures using the building blocks provided by the EVM.Selector IndexingConsidering that jump labels are 2 bytes large and selectors are 4-byte (32-bit) large values that wouldrequire an 8.5GB array or map (2 ** 32 * 2) so that every single selector can be mapped to aunique jump label. To reduce the size of our lookup table and make it fit into the 24kB Spurious Dragoncontract size limit we’ll need to extract an index thatsits in a smaller range, however, this means that different selectors will result in the same index.This is why the final, 19-gas direct selector comparison is necessary as we need to rule out collisionsto make sure that when our contract is called with a selector that’s not part of the ABI it’llactually revert:There are different ways to extract a unique index from the 4-byte selector:HashingHashing is the most general-purpose way to map a set of selectors to a unique set of indices ina tight range. One just needs to search for a nonce that when hashed together with the selectorresults in a unique index (mod n). While it may require some longer searching for larger selector sets thesearch time can be reduced by increasing the accepted output range for indices. Code for such anindex extractor would look something like this:// Gets selector.pc calldataload 0xe0 shr // [selector]// Combine nonce with selector, `nonce` should be a number shifted left by 32 to ensure// it doesn't overlap with the actual selector.dup1 [NONCE] or // [hash_preimage, selector]// Store in memory for hashing.msize mstore // [selector]msize returndatasize sha3 // [hash, selector][MASK] and // [index, selector]While this approach is quite general-purpose it’s not very efficient. With the requiredmemory and SHA3 opcode use it brings the base cost of this approach to 93 gas, not including the codeto do the table lookup. Meaning it’ll only really pay off when your contract starts to have&gt;25 (or &gt;40) functions, depending on the type of lookup table you’re using.That’s why as an alternative to hashing it can be cheaper to make a custom “hashing function” thatcondenses the selector to an index by combining bitwise-xor, bit-shifting and modulus operations ina more creative fashion. Either approach will require you to iterate through many combinations tofind the most efficient setup.However, if you’re lucky and your selector set is smaller you can also use one of the following, moreefficient selector indexing approaches:Direct Bit-MaskingLooking at the selectors of the functions in your ABI as 32-bit binary values you can look toidentify a set of bit positions across a tight range that are unique to all selectors e.g.: xx xxx[0x06fdde03] 00000110111111011101111000000011 - {00___011} name()[0x95d89b41] 10010101110110001001101101000001 - {01___111} symbol()[0x313ce567] 00110001001111001110010101100111 - {11___100} decimals()[0x18160ddd] 00011000000101100000110111011101 - {01___000} totalSupply()[0x23b872dd] 00100011101110000111001011011101 - {10___110} transferFrom(address,address,uint256)[0xa9059cbb] 10101001000001011001110010111011 - {10___100} transfer(address, uint256)[0x70a08231] 01110000101000001000001000110001 - {11___010} balanceOf(address)[0x095ea7b3] 00001001010111101010011110110011 - {00___101} approve(address,uint256)[0xdd62ed3e] 11011101011000101110110100111110 - {01___101} allowance(address, address)[0xd0e30db0] 11010000111000110000110110110000 - {01___011} deposit()[0xb760faf9] 10110111011000001111101011111001 - {11___101} depositTo(address)[0x2e1a7d4d] 00101110000110100111110101001101 - {10___000} withdraw(uint256)[0x853828b6] 10000101001110000010100010110110 - {00___100} withdrawAll()[0xca9add8f] 11001010100110101101110110001111 - {00___010} withdrawAllTo(address)[0x205c2878] 00100000010111000010100001111000 - {10___001} withdrawTo(address, uint256)[0x9470b0bd] 10010100011100001011000010111101 - {01___001} withdrawFrom(address, uint256)[0x4a4089cc] 01001010010000001000100111001100 - {00___001} withdrawFromTo(address, address, uint256)[0x3644e515] 00110110010001001110010100010101 - {11___001} DOMAIN_SEPARATOR()[0x7ecebe00] 01111110110011101011111000000000 - {11___011} nonces(address)[0xd505accf] 11010101000001011010110011001111 - {01___100} permit(address, address, uint256, uint256, uint8, bytes32, bytes32)[0xac9650d8] 10101100100101100101000011011000 - {10___010} multicall(bytes[])In the above example, there’s a set of 5-bits in an 8-bit range that are unique across all selectors.The tight range is ideal as it means the range of values between the lowest and highest index is notso wide and the table in our contract can therefore be smaller. Extracting the index from a selectorwould require the operator (selector &gt;&gt; MAGIC_SHIFT) &amp; MAGIC_MASK which for the above examplewould be (selector &gt;&gt; 22) &amp; 0xc7. In Huff:// Gets selector.pc calldataload 0xe0 shr // [selector]// Selector copied onto stack because it would be needed for direct comparison laterdup1 // [selector; selector]0x16 shr 0xc7 and // [index ∈ (0x00,0xff); selector ]Bit SplicingWhile there will always be a set of bit indices that are unique across all selectors they may notalways be across a tight range, in fact, it becomes increasingly less likely as the number offunctions in your contract increases. This presents an issue as the resulting index needs to be ina tight range for the table size to be practical. However, there are a few tricks you can use tobring bits together that aren’t close to each other.As an example let’s Imagine you have an ABI such that the set of unique bits across all selectorslooks as follows (marked by X):0 0 0 0 0 0 0 0 X X X X 0 0 0 0 0 0 0 0 0 0 0 X 0 X 0 0 0 0 0 0Extracted with the code: SELECTOR() 0x6 shr 0x3c005 and, representing a range of 18 bits. However,we can add a few simple operations to close the gap between the upper bits and the lower bits. Byshifting and then bitwise OR-ing the values together we can create a resulting index that willalways be in a smaller range:Initially extracted: A B C D 0 0 0 0 0 0 0 0 0 0 0 E 0 FShifted right by 11: 0 0 0 0 0 0 0 0 0 0 0 A B C D 0 0 0--------------------------------------------------------OR-ed together : A B C D 0 0 0 0 0 0 0 A B C D E 0 FLower bits masked : 0 0 0 0 0 0 0 0 0 0 0 A B C D E 0 FWith just 3 operations (shift, or, and) we reduced the range of the resulting index whilekeeping the unique bits, in Huff this would look like this (0xb is 11 in hexadecimal):// Gets selector.pc calldataload 0xe0 shr // [selector]dup1 0x6 shr 0x3c005 and // [wide_index, selector]dup1 0xb shr // [shifted_top_bits, wide_index, selector]or 0x7f and // [narrow_index, selector]This is quite efficient as it doesn’t use a lot of opcodes and they’re all base-2 operations(bit-wise OR, bit-shift, bit-wise AND) which cost 3 gas vs. other arithmetic operations like mod,div and mul which could also be used but cost 5 gas each.🏗️ Building Lookup Tables in the EVMSimilar to how there are several approaches with varying efficiencies when building a selectorindexer there are also several approaches to building and retrieving values from lookup tables.Push TablesWith these tables, you can pack up to 16x 2-byte jump destinations into a single value and then havethe table be pushed in its entirety onto the stack using a PUSH opcode. This is quite efficient as“loading” the table itself only requires 3 gas and retrieving a value 12 gas, assuming your index isalready multiplied by 16 to ensure it’s a useful offset. The big constraint with this approach isthat it only supports indices that are in the range 0-15 which will be an issue if your contract hasmore than 16 functions that need to be jumped to. Assuming you’re able to find a group of 4-bitsthat is unique across all selectors the switch would look as follows:// Gets selector.pc calldataload 0xe0 shr // [selector][JUMP_TABLE] // [table]dup2 [IND_SHIFT] shr // [shifted_selector, table, selector]// Mask offset by 4 bits to ensure the result will be a valid table shift.0xf0 and // [index, table, selector]shr 0xffff and // [jump_dest, selector]jump// At the jump destinations, check if selector matches:0x???????? sub error_dest jumpiFUNCTION_LOGIC()error_dest: 0x0 0x0 revertYou can fit more than 16 labels into a push table if each label is smaller than 16 bits. Thiswill almost certainly be the case as the current contract size limit is 24kB meaning the largestrealistic jump destination would only require 15 bits. Depending on your contract size your jumplabels may take up even less space. However, an important thing to note is that if the bit size ofyour labels is not a power of 2 you’ll need an additional push and multiplication operation tocompute the shift for the lookup. Example with jump label size of 12-bits (0xc in hexadecimal):// Gets selector.pc calldataload 0xe0 shr // [selector][JUMP_TABLE] // [table]dup2 [IND_SHIFT] shr // [shifted_selector, table, selector]// Mask unique bits0x1f and // [index, table, selector]// Multiply by 12 to get the offset of the label0xc mul // [label_offset, table, selector]shr 0xfff and // [jump_dest, selector]jump// At the jump destinations, check if selector matches:0x???????? sub error_dest jumpiFUNCTION_LOGIC()error_dest: 0x0 0x0 revertTable TreesPush tables can be extended to support even more functions by creating a shallow treewhereby the first table selects a sub-table that determines the final destination. While this istechnically still a tree with logarithmic $O(\\log n)$ time complexity, practically its timecomplexity is constant as you’ll never need a tree that’s deeper than 3 levels. Using such a tree makesselector indexing even easier as you don’t need to find a tight bit range that uniquely identifiesall selectors but instead, you just need to find a smaller range that groups selectors ingroups no larger than 16, with each group able to have their own range.As an example imagine a contract with 128-functions:0x4482d182 0xf5d05a80 0x24ce2433 0x82c35051 0x9eb17fb7 0x4802a7fd 0x2c0e5bac 0xf83131230x4e2464cd 0x9d5f65e1 0x0fa9584d 0x6f019090 0xf4f3fbb8 0x29cd002a 0xb82bf507 0x4c0656c30xbd0a5449 0x59327a62 0x3c253f7f 0x969e72a9 0x0a7a2ceb 0x5c46eeab 0xac4ab926 0x84089c910x4dc74a98 0x55cac09d 0x02a69ada 0x5acc746b 0xebab72a8 0xce280460 0x5820c09a 0x522fecc80xced910c1 0xaed519b4 0xe850db0f 0x144db955 0x64a42fda 0xb569a22a 0x78890a44 0x96eb0ebc0x237e81b6 0x605a6e34 0x63ae1af7 0x25a86543 0xd7d01f4a 0xf6763fed 0xc8fa772d 0x10897e4e0xb85abce6 0xaa77f58e 0x3bedf0bb 0x149791ea 0x3eeb3d98 0xe59dc2db 0x063cdcb2 0xfadb48230xa008b45a 0xb84df3af 0x9fb39812 0xc8a0ebf2 0xe7ad912d 0x94a32c56 0xd2b1a96a 0xd4a8589d0x4dd90963 0xb4830428 0x7cf58051 0x6573a075 0xcdc89bc1 0x7889cf21 0x03682317 0xc06a9ed20x46f2c6b0 0x06544126 0x078d22e1 0x4f492320 0xb6a69d6c 0x103eedc6 0x2f3cb837 0xeac9fedb0xf6d647f0 0x6b0dc469 0x81a6d8df 0x2b2911a4 0x02e71741 0xc746d79d 0x0c97fce9 0xff4ab2e20xb83ac239 0x40341065 0x00bc2475 0x36dd0f40 0x378a6476 0x6491330a 0x8a104473 0x0d33ae640xb68734d9 0xde45a986 0xd70e58ee 0xebaf8b57 0xcc5ade18 0x94fbb841 0xcd42e3d1 0xb387c57a0xde1e50f3 0x94a40bdf 0xc59f70c9 0x9ff884da 0xc3a075fe 0x81ebea85 0x75b569d7 0x07dcb7bf0x30aa9aae 0x21770e06 0x88e13c98 0x9ff7735a 0x0d2c39db 0x656f06d0 0x5971a031 0x4925d0350x042a2f53 0x50fce891 0xb673685b 0xa54741fc 0x9c527625 0xa55cf11c 0x2ba1c786 0x3bd3b8ecYou can then find a 4-bit mask that splits the selectors into distinct groups:root mask: 00000000000000000000000000001111group (0000): gmask: 00000000000000000000000001111000 [0xf5d05a80,0x6f019090,0xce280460,0x46f2c6b0,0x4f492320,0xf6d647f0,0x36dd0f40,0x656f06d0]group (0010): gmask: 00000000000000000000000011110000 [0x4482d182,0x59327a62,0x063cdcb2,0x9fb39812,0xc8a0ebf2,0xc06a9ed2,0xff4ab2e2]group (0100): gmask: 00000000000000000000000011110000 [0xaed519b4,0x78890a44,0x605a6e34,0x2b2911a4,0x0d33ae64]group (0101): gmask: 00000000000000001111000000000000 [0x144db955,0x6573a075,0x40341065,0x00bc2475,0x81ebea85,0x4925d035,0x9c527625]group (0110): gmask: 00001111000000000000000000000000 [0xac4ab926,0x237e81b6,0xb85abce6,0x94a32c56,0x06544126,0x103eedc6,0x378a6476,0xde45a986,0x21770e06,0x2ba1c786]group (0111): gmask: 00000000000000000000000011110000 [0x9eb17fb7,0xb82bf507,0x63ae1af7,0x03682317,0x2f3cb837,0xebaf8b57,0x75b569d7]group (1000): gmask: 11110000000000000000000000000000 [0xf4f3fbb8,0x4dc74a98,0xebab72a8,0x522fecc8,0x3eeb3d98,0xb4830428,0xcc5ade18,0x88e13c98]group (1001): gmask: 00000000000000000000000011110000 [0xbd0a5449,0x969e72a9,0x6b0dc469,0x0c97fce9,0xb83ac239,0xb68734d9,0xc59f70c9]group (1011): gmask: 00000000000000000001111000000000 [0x0a7a2ceb,0x5c46eeab,0x5acc746b,0x3bedf0bb,0xe59dc2db,0xeac9fedb,0x0d2c39db,0xb673685b]group (1100): gmask: 00000000000000000000000011110000 [0x2c0e5bac,0x96eb0ebc,0xb6a69d6c,0xa54741fc,0xa55cf11c,0x3bd3b8ec]group (1110): gmask: 00000000000000000000000001111000 [0x10897e4e,0xaa77f58e,0xd70e58ee,0xc3a075fe,0x30aa9aae]group (1111): gmask: 00000000000000000001111000000000 [0x3c253f7f,0xe850db0f,0xb84df3af,0x81a6d8df,0x94a40bdf,0x07dcb7bf]Table in CodeAs an alternative to using the PUSH opcode to store &amp; load lookup tables, which limits you to32 bytes at a time you can store larger lookup tables directly in the bytecode and load the targetlabel with CODECOPY. In Huff this is enabled by the jump-table syntax:// Example for non-packed table from Huff's docs#define jumptable SWITCH_TABLE { jump_one jump_two jump_three jump_four}// Packed version#define jumptable__packed SWITCH_TABLE_TIGHT { jump_one jump_two jump_three jump_four}#define macro MAIN() = takes(0) returns(0) { // Push bytecode offset of table onto the stack __tablestart(SWITCH_TABLE)}While this approach lends itself well to larger selectors sets it does use more gas than a 1-levelpush table as you need to copy the jump dest into memory using CODECOPY and then load it usingMLOAD.🏃 Code as Table / Direct JumpingInstead of looking up the jump destination based on some derived index you could directly convert itto a jump destination and jump to it. To do this the jump destinations should be evenly spaced sothat the index can easily be converted to a jump dest: jump_dest = index * dest_spacing + offset.Even spacing comes at the large downside of increased bytecode size as you’ll need to pad thebytecode of all your methods to be as large as your largest method:Illustration of the bytecode of a contract utilizing padding to allow for direct jump destinationdeterminationIn Huff:GET_SELECTOR() // [selector]dup1 GET_IND() // [index, selector][SPACING] mul [OFFSET] add // [jump_dest, selector]jump// Code At every function// Label required in Huff to ensure `JUMPDEST` is generated during compilation// otherwise dynamic `JUMP` will revertfn1:// '0x????????' represents the expected selector0x???????? sub revert_dest jumpi // Actual function logic// Bytecode padding (simplest being 0-bytes which are interpreted as stop opcodes)stop stop // ......revert_dest: 0x0 0x0 revertDepending on your chosen selector indexing method, entire code sections may have to be empty withonly a revert at the beginning to catch incorrect selectors. The “Selector Check” codeensures that the selector is actually part of the ABI and didn’t just e.g. have the same bits asa different valid selector.Saving on Padding by rearranging code:Instead of having the different functions have the same bytecode size we can move up theselector-check code and pad those instances instead of the actual functions to massively reduce theoverall bytecode. This can be crucial because depending on the size of functions and index range itmay not even be feasible to pad functions. Since the selector-check utilizes a JUMPI-op anyway thedestination can simply be set to the actual functions instead of the revert code. This does howeveradd 1 gas to the runtime gas cost due to the added JUMPDEST. Rearranging the code makes it looklike this: The blocks are not meant to be an accurate, proportional display of bytecode size but rathera rough, visual representationGET_SELECTOR() // [selector]dup1 GET_IND() // [index, selector][SPACING] mul [OFFSET] add // [jump_dest, selector]jump// For every possible destination:dest1: 0x???????? eq fn1 jumpi 0x0 0x0 revertdest2: 0x???????? eq fn2 jumpi 0x0 0x0 revertdest3: 0x0 0x0 revert stop stop stop stop stop stop stop stop stop stop // (10-bytes padding required to match `PUSH4 &lt;4x?&gt; EQ PUSH2 &lt;2x?&gt; JUMPI`)dest4: 0x???????? eq fn3 jumpi 0x0 0x0 revertfn1: // Code for function 1fn2: // Code for function 2fn3: // Code for function 3The packed block of selector-checks and reverts is also why I like to call this approach the “codeas table” approach because while it’s not exactly a lookup table, the contract’s code acts like one bytranslating the initial jump to the final destination through its execution.Bringing it TogetherWhen building selector switches the main tradeoff will be between gas efficiency and code size. Withoutsacrificing too much in code size you can already have large gains in gas efficiency, especiallyfor contracts with larger selector sets. To save even more gas you could sacrifice collision resistance,removing the selector-check. However, I’d highly discourage this as it may lead to vulnerabilities ininteracting contracts that expect external contracts to revert for calls to unsupported methods.To build constant gas function dispatchers for your contracts you’ll have to carefully compare andtest different combinations of components to find what best suits your needs.💫 Special Branches💵 Payable FunctionsBeyond simply checking the selector and identifying the section of code that belongs to the functionyou may also want your function dispatcher to check the call’s msg.value (aka callvalue). There are severalreasons why it’s beneficial from an optimization perspective to put callvalue checks in the functiondispatcher: It can make the require(msg.value == 0) check for non-payable functions cheaper It’ll help the dispatcher route to payable methods more efficientlyBinary Search Function DispatchersFor a binary search function dispatcher you can put a branch checking the callvalue at the verybeginning: The JUMPI opcode jumps to the target destination whenever the condition value on the stack isnon-zero. This means you don’t have to waste gas adding ISZERO ISZERO prior to a JUMPI forcondition values that may be &gt;1. This fact also allows you to save gas in certain situations byinverting conditions via the removal of a single ISZERO and swapping the code that is presentafter the JUMPI and at the JUMPDEST.// load selectorpc calldataload 0xe0 shrcallvalue payable_fn_tree jumpi// binary search function dispatcher with only 0-ETH functionspayable_fn_tree:// binary search function dispatcher with only ETH-accepting functionsThis will make your contract smaller as you won’t have to repeat callvalue checking codefor every function and it’ll make payable functions cheaper as it’ll shorten the path to the payablefunctions when value is sent. What you also have to be careful of is if your payable functions arealso meant to be able to not accept ETH, i.e. being executed when msg.value == 0. If you don’tinclude the selectors of the payable functions in the non-payable side of the tree you won’t be ableto call the methods without callvalue; this may be desirable in some cases.Constant Gas Function DispatchersDepending on your selector indexer you may not necessarily want to put your callvalue check at the beginning ofyour contract. This is because it’ll add the check to the execution flow of all functionsregardless if they’re payable or not. By only adding the check to the non-payable methods you’ll makepayable functions cheaper. You can easily use the same JUMPI from the selector check for thecallvalue check:selector_check_dest: &lt;expected_selector&gt; eq // [selector == expected_selector ? 1 : 0] callvalue lt // [msg.value &lt; selector == expected_selector ? 1 : 0] &lt;final_function_dest&gt; jumpi returndatasize returndatasize revertThis above code works because the result of EQ in the EVM is either 0 or 1, meaning that the resultingcondition value can only be 1 if both the selector matched and the msg.value is strictlyless than 1, meaning 0. If the selectors don’t match there’s no msg.value that’ll satisfythe LT(CALLVALUE(), EQ(...)) comparison. This selector check block is great because it’s exactly16 bytes large (assuming 2-byte jump dest and 4-byte selector) allowing you to use cheaper base-2operations to convert your index into the jump destination.Fallback FunctionsReceive fallbackThe receive fallback function is typically used to accept ETH via empty calls. In Solidity it’sdefined with the receive keyword:receive() payable external { // ...}To check whether thecurrent call is to the receive fallback function you can treat it like a call with the 0x00000000selector but no calldata i.e. a CALLDATASIZE of 0. This is because in the EVM if you try to readcalldata beyond what was actually provided via CALLDATALOAD or CALLDATACOPY the EVM will pad theresult with 0x00-bytes. Meaning that our selector extracting code pc calldataload 0xe0 shr willplace a 0 on the stack when the calldata is empty, the same as if you were to call the contractwith the actual zero selector 0x00000000. So how do you differentiate these cases? As previouslyeluded to, CALLDATASIZE will push the length of calldata to the stack, this allows you to easilycheck which is which (if you have both in your contract): calldatasize iszero receive_fn jumpidup1 0x00000000 eq zero_selector_fn jumpiThe fact that 0 is pushed to the stack as the selector for the receive fallback is especiallyuseful for constant gas dispatchers as you don’t have to change your selector indexer or tablelookup for it. The only change required is the final selector check which can be changed from beingselector based to calldatasize.Fallback-FallbackThe fallback-fallback function is the function called when nothing else matches and in Solidity itaccepts arbitrary calldata. Generally, I’d heavily discourage the use of the fallback method,unless you’re writing a base proxy contract as it creates a foot gun other developers could step into.Multicoin’s bridge was exploitedprecisely because they were not expecting WETH9’s silent fallback function. Therefore I won’t go toomuch into it but essentially if you need a fallback function you just need to change the 0x0 0x0revert at the end of all branches to a fallback jump to ensure that all code paths continue inthe fallback function if an appropriate selector was not found.METH’s Constant Gas Function DispatcherFor METH, I built a practical 23-function (24 if you countthe receive fallback), constant* gas function dispatcher that costs about half what the average costfor a normal binary search function dispatcher would be. I put an asterisk next to the “constant” becausethe cost isn’t the same for all functions: Category Gas Cost Receive Fallback 54 Payable Functions 55 Non-payable Functions 60 Note: the gas cost does not include the cost to read the selector as I don’t consider that part ofthe “dispatcher” and it’s required regardless of the type of dispatcher you create. Update:The above gas cost figures are no longer fully accurate for METH’s function dispatcher. This isbecause for certain methods with checks e.g. transfer, METH now combines the selector-check withthe balance-check to save on gas by reducing the amount of unique JUMPI instructions. The costof the JUMPI is therefore no longer solely carried by the dispatcher and is in practice reduceddepending how you want to attribute its costs.The dispatcher is so efficient because of how the selectors are laid out. Specifically, the highest8-bits of the selectors are unique for all functions. 8-bits or 0-255 is a small enough range wherethe locations for the selector checks still fit into the 24kB contract size limit. The unique bitsbeing the highest also means I only need to shift and mask the value once to extract the index,clear the dirty bits and construct the jump destination:pc calldataload 0xe0 shr // [selector]dup1 // [selector; selector]// Shift right by 20 to preserve the 12 topmost bits0x14 shr // [sbits ∈ (b000000000000, b111111111111); selector]// Overwrite the lower 4 bits with 1, keeping only the unique upper 8 bits0x0f or // [index * 16 + 15; selector]// Jump to the created destinationjumpUsing a bitwise-OR instead of AND to “clear” the lower bits is a cool trick in my opinion because itserves two purposes: It “evens out” the lower bits of the output value to ensure that the possible output values areevenly spaced out It ensures the minimum output value is 15 or b1111, meaning the receive-fallback function and selectors with 8 zero upper bits can still result in a valid jump destination without having to use an additional PUSH &amp; ADD operation.I then use the “code as table” approach adding selector checks with the final destinations at allvalid jump destinations and a simple JUMPDEST PUSH0 PUSH0 REVERT, with padding at all invaliddestinations, encapsulated in the NO_MATCH macro. Here’s an excerpt from theHuff code: dest_0x18f: NON_PAYABLE_FUNC_CHECK(0x18160ddd, totalSupply_final_dest) dest_0x19f: NO_MATCH() dest_0x1af: NO_MATCH() dest_0x1bf: NO_MATCH() dest_0x1cf: NO_MATCH() dest_0x1df: NO_MATCH() dest_0x1ef: NO_MATCH() dest_0x1ff: NO_MATCH() dest_0x20f: NON_PAYABLE_FUNC_CHECK(0x205c2878, withdrawTo_final_dest) dest_0x21f: NO_MATCH() dest_0x22f: NO_MATCH() dest_0x23f: NON_PAYABLE_FUNC_CHECK(0x23b872dd, transferFrom_final_dest) dest_0x24f: NO_MATCH() dest_0x25f: NO_MATCH() dest_0x26f: NO_MATCH() dest_0x27f: NO_MATCH() dest_0x28f: PAYABLE_FUNC_CHECK(0x28026ace, depositAndApprove_final_dest) dest_0x29f: NO_MATCH() dest_0x2af: NO_MATCH() dest_0x2bf: NO_MATCH() dest_0x2cf: NO_MATCH() dest_0x2df: NO_MATCH() dest_0x2ef: NON_PAYABLE_FUNC_CHECK(0x2e1a7d4d, withdraw_final_dest)The main downside to this function dispatcher is code size, with 256 possible destinationsand each block being padded to 16 bytes large the function dispatcher alone is 4.1 kB large 🤯.However, this is a worthy tradeoff to me as the cost of the contract’s size is one-time and paid atdeployment vs. the runtime gas cost which will continuously be paid by all users of METH. Update:METH has moved to using the “padded function” approach whereby each destination is 64-bytes large,blowing up the contract’s size to 16kB (the majority of which is padding). This is mainly to allowfor JUMPI reuse between the selector-check and other checks. Due to certain functions beinglarger than 64-bytes they overflow into the next block meaning certain unimplemented selectorswill revert exceptionally (using all gas) rather than being simply reverted.Efficient Function Dispatchers Post EIP-4200In the suite of upcoming EOF upgrades to the EVM, EIP-4200proposes adding new jump opcodes to replace the existing JUMP, JUMPI and JUMPDEST opcodes thatare responsible for branching and jumping in EVM contracts today. The RJUMP and RJUMPI opcodesare 1-to-1 replacements of the JUMP and JUMPI opcodes with a few minor differences: no JUMPDESTwill be required at the destination (-1 gas), they’ll only accept static relative jump destinations thataren’t pushed (-3 gas) and each only cost 2 gas meaning direct jumps (RJUMP &lt;dest&gt; vs. PUSH &lt;dest&gt;JUMP ... JUMP) will be 10 gas cheaper and conditional jumps will be 12 gas cheaper. Note that the EIPis not yet final so the gas costs may change.However, the EIP-4200 opcode that’ll have the biggest impact on function dispatchers in my opinion is theRJUMPV opcode. The RJUMPV opcode is intended to only cost 4 gas and acts as a jump table with upto 256 jump destinations (technically only 255 right now but I’ve proposed a changethat’d allow up to 256). At runtime, the opcode would accept an index between 0-255 and then jump tothe configured jump destination. The table doesn’t have to be 256 large and you can even leave“gaps” in the form of 0 offsets which will default to not jumping. The RJUMPV opcode would allowconstant gas function dispatchers like METH’s to not only be cheaper but take up less bytecode.It’ll also make it easier for compilers of high-level languages like Solidity, Vyper, Fe, Sway, etc.to construct constant gas dispatchers in a generalized manner. This is because now theselector indexer can have an index range size of up to 256 at no big cost.ConclusionFunction dispatchers are an important part of smart contracts and have so far remained relativelyunexplored in the optimizooor space. Especially pre-EIP-4200 there’s a lot of room for clevertricks, optimizing the dispatcher of a larger contract can help shave 10, 20, 40+ gas from your contractwhich can be a lot in the land of hyper-optimized Huff contracts.I hope this post was valuable to you, feel free to give your thoughts and feedback and follow meon my Twitter @real_philogy for more technical crypto content.Footnotes Joseph A. Carr, Attribution, via Wikimedia Commons &#8617; Every contract written in high level languages that target the EVM like Solidity, Vyper, Fe have selector switches by default, however certain MEV bot contracts written in low level languages / assembly may omit an ABI compliant selector switch to save on even more gas. &#8617; https://twitter.com/z0age/status/1618704547404468224 &#8617; " } ]
